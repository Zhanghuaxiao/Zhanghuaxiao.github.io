<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue的functionnal使用]]></title>
    <url>%2F2020%2F05%2F25%2Fvue%E7%9A%84functionnal%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vue的functionnal使用 Vue.js 组件提供了一个 functional 开关，设置为 true 后，就可以让组件变为无状态、无实例的函数化组件。因为只是函数，所以渲染的开销相对来说，较小。 函数化的组件中的 Render 函数，提供了第二个参数 context 作为上下文，data、props、slots、children 以及 parent 都可以通过 context 来访问。 1.新建一个functionnal.js（名字随意，只要是js文件）文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//图片组件设置 // eslint-disable-next-line no-unused-vars var imgOptions = &#123; props: ["data"], render: function(createElement) &#123; return createElement("div", [ createElement("p", "图片组件"), createElement("img", &#123; attrs: &#123; src: this.data.url, height: 300, weight: 400 &#125; &#125;) ]); &#125;&#125;;//文字组件设置// eslint-disable-next-line no-unused-varsvar textOptions = &#123; props: ["data"], render: function(createElement) &#123; return createElement("div", [ createElement("p", "文本组件"), createElement("span", &#123; attrs: &#123; height: 300, weight: 400 &#125; &#125;), this.data.content ]); &#125;&#125;;// eslint-disable-next-line no-unused-varsvar renderData = &#123;&#125;;export default &#123; functional: true, render(createElement, &#123; data &#125;) &#123; console.log(data); if (data.attrs.data.type === "text") &#123; renderData = textOptions; &#125; else if (data.attrs.data.type === "img") &#123; renderData = imgOptions; &#125; return createElement(renderData, data); &#125;&#125;; 2.例如在About.vue文件中使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div class="about"&gt; &lt;h1&gt;functionnal的使用&lt;/h1&gt; &lt;button @click="log('img')"&gt;图片&lt;/button&gt; &lt;button @click="log('text')"&gt;文字&lt;/button&gt; &lt;functionalVue :data="data"&gt;&lt;/functionalVue&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import functionalVue from "./functionnal";export default &#123; data() &#123; return &#123; data: &#123;&#125; &#125;; &#125;, components: &#123; functionalVue &#125;, methods: &#123; log(type) &#123; if (type === "img") &#123; this.data = &#123; type: type, url: "http://pic-bucket.ws.126.net/photo/0001/2019-02-07/E7D8PON900AO0001NOS.jpg" &#125;; &#125; else &#123; this.data = &#123; type: type, content: "《流浪地球》中的科学：太阳何时吞并地球？科学家已经给出时间表" &#125;; &#125; &#125; &#125;, created() &#123; this.data = &#123; type: "text", content: "《流浪地球》中的科学：太阳何时吞并地球？科学家已经给出时间表" &#125;; &#125;&#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue的functionnal使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何清除已设置的npm淘宝镜像]]></title>
    <url>%2F2020%2F05%2F19%2F%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E5%B7%B2%E8%AE%BE%E7%BD%AE%E7%9A%84npm%E6%B7%98%E5%AE%9D%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[1.设置淘宝的是：npm config set registry https://registry.npm.taobao.org 2.不想用他们的，再设置回原来的就可以了：npm config set registry https://registry.npmjs.org]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>如何清除已设置的npm淘宝镜像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodeJs回顾记录]]></title>
    <url>%2F2019%2F11%2F25%2FnodeJs%E5%9B%9E%E9%A1%BE%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时 在node_modules下的文件直接使用 require(‘nav’) 使用 123456789node_modules下创建nav文件夹再创建nav.js//nav.js *** 主要使用nmp init -y 初始化 package.json文件中 &quot;main&quot;: &quot;nav.js&quot; *** const str = &apos;hello world come from nav.js&apos; module.exports = str//其他js文件 const nav = require(&apos;nav&apos;) console.log(nav) //hello world come from nav.js 常用的fs模块API使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778const fs = require(&apos;fs&apos;)// 1. 异步读取文件fs.readFile(&apos;./demo.txt&apos;,function(err,fd)&#123; if(err)&#123; return console.error(err) &#125; console.log(fd.toString())&#125;)// 2. 打开文件夹fs.open(&apos;./demo.txt&apos;,function(err,fd)&#123; if(err)&#123; return console.error(err) &#125; console.log(fd)&#125;)// 3. 获取文件信息fs.stat(&apos;./demo.txt&apos;,function(err,fd)&#123; if(err)&#123; return console.error(err) &#125; console.log(fd.isFile())&#125;)// 4. 写入文件fs.writeFile(&apos;log.js&apos;, &apos;写入日志3&apos;, function (err) &#123; if (err) &#123; return console.error(err) &#125;&#125;)// 5. 写入内容fs.appendFile(&apos;./log.js&apos;,&apos;使用appendFile写入内容\n&apos;,function(err)&#123; if (err) &#123; return console.error(err) &#125; console.log(&apos;写入成功&apos;)&#125;)// 6. 读取目录 把目录下面的文件和文件夹都获取到fs.readdir(&apos;./src&apos;,function(err,fl)&#123; if (err) &#123; return console.error(err) &#125; console.log(fl)&#125;)// 7. fs.rename 1.重命名 2.剪切fs.rename(&apos;./src/rename.js&apos;,&apos;./src/rename1.js&apos;,function(err,res)&#123; if (err) &#123; return console.error(err) &#125; console.log(&apos;重命名成功&apos;)&#125;)fs.rename(&apos;./src/index.html&apos;,&apos;./static/index.js&apos;,function(err,re)&#123; if (err) &#123; return console.error(err) &#125; console.log(&apos;剪切成功&apos;)&#125;)// 8. fs.rmdir 删除目录fs.rmdir(&apos;index.html&apos;, function (err, re) &#123; if (err) &#123; return console.error(err) &#125; console.log(&apos;删除目录成功&apos;)&#125;)//9. fs.unlink 删除文件fs.unlink(&apos;index.html&apos;, function (err, re) &#123; if (err) &#123; return console.error(err) &#125; console.log(&apos;删除文件成功&apos;)&#125;) 2.1 练习（打印src下是目录的文件)1234567891011121314151617181920 //因为是异步操作，所以使用递归加匿名函数自调解决 fs.readdir(&apos;src&apos;,function(err,files)&#123; var allFile = [] if(err)&#123; return console.error(err) &#125;else&#123; (function a(i)&#123; if(files.length == i)&#123; console.log(allFile) return false &#125; fs.stat(&apos;src/&apos;+files[i],function(err,fd)&#123; if(fd.isDirectory())&#123; allFile.push(files[i]) &#125; a(i+1) &#125;) &#125;)(0) &#125;&#125;) 读入流、写入流和管道读取 12345678910111213141516171819202122232425262728293031323334353637const fs = require(&apos;fs&apos;);//文件读取流（就是一段段读取）var readStream = fs.createReadStream(&apos;demo.txt&apos;);var str = &apos;&apos;;var count = 0;readStream.on(&apos;data&apos;,function(chunk)&#123; str += chunk; count++;&#125;)readStream.on(&apos;end&apos;,function(chunk)&#123; console.log(count) console.log(str)&#125;)//文件写入流var writeStream = fs.createWriteStream(&apos;input.txt&apos;);var data = &apos;使用createWriteStream流写入文件\n&apos;//也可以使用for写入for(var i=0;i&lt;90;i++)&#123; writeStream.write(data,&apos;utf-8&apos;);&#125;writeStream.end(); //标记写入完成 能触发以下方法// 成功writeStream.on(&apos;finish&apos;,function()&#123; console.log(&apos;写入完成&apos;)&#125;)//失败writeStream.on(&apos;error&apos;,function()&#123; console.log(&apos;写入完成&apos;)&#125;)//读取一个文件内容写入到另一个文件中var readerStream = fs.createReadStream(&apos;demo.txt&apos;); //读取文件var writeStream = fs.createWriteStream(&apos;input.txt&apos;); //创建一个可写入流readerStream.pipe(writeStream)console.log(&apos;程序执行完毕&apos;) 写一个简单的web服务器，可以根据输入同url返回相应的文件内容 123456789101112131415161718192021222324const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;);const path = require(&apos;path&apos;);const mime = require(&apos;./static/model/mime&apos;);http.createServer(function (req, res) &#123; var pathname = req.url; pathname == &apos;/&apos; ? pathname = &apos;./index.html&apos; : &quot;&quot;; //获取文件的后缀名 let exname = path.extname(pathname) if (pathname != &apos;/favicon.ico&apos;) &#123; fs.readFile(&apos;static/&apos; + pathname, function (err, fd) &#123; if (err) &#123; return console.error(err) &#125; else &#123; var mimeName = mime.getMime(exname) //使用自己写的方法返回text-html,text-css等 res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;mimeName;chart=utf-8&quot; &#125;) res.end(fd) &#125; &#125;) &#125;&#125;).listen(8888) 4.1 使用回调函数解决异步问题 12345678910111213const fs = require(&apos;fs&apos;);console.log(1)function getMime(callback)&#123; fs.readFile(&apos;input.txt&apos;,function(err,fd)&#123; if(err)&#123; return console.error(err) &#125; callback(fd) &#125;)&#125;getMime(function(data)&#123; console.log(data.toString())&#125;) 4.2 使用nodejs自带的events方法解决异步问题 123456789101112131415const fs = require(&apos;fs&apos;);const events = require(&apos;events&apos;);var EventEmitter = new events.EventEmitter();fs.readFile(&apos;input.txt&apos;, function (err, fd) &#123; if (err) &#123; return console.error(err) &#125; EventEmitter.emit(&apos;to_parent&apos;, fd)&#125;)EventEmitter.on(&apos;to_parent&apos;, function (data) &#123; console.log(data.toString())&#125;)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中的$emit $on $once $off的使用]]></title>
    <url>%2F2019%2F08%2F23%2Fvue%E7%9A%84-emit-on-once-off%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近的大事就是香港暴乱,做好自己就是对祖国的最好支持！ 1.如果对以上方法还不了解的可以点击传送门大致了解一下😯2.都说实践出真知，复制以下代码，动动小手点击下就全懂啦！123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;body&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;children-component @aa="aa"&gt;&lt;/children-component&gt; &lt;br/&gt; &lt;button @click="removeClick"&gt;父组件按钮使用$off移除$on监听&lt;/button&gt; &lt;/div&gt; &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt; &lt;script&gt; var bus = new Vue() var children = &#123; data()&#123; return&#123; data:"" &#125; &#125;, methods: &#123; childrenClick()&#123; bus.$emit('aa','子组件通过emit发送过来的数据') &#125;, hanldClick()&#123; bus.$emit('bb','子组件用来探索$once') &#125; &#125;, template:`&lt;div&gt; &lt;button @click="childrenClick"&gt;子组件使用$emit发送数据，父组件使用$on监听&lt;/button&gt;&lt;br/&gt;&lt;br/&gt; &lt;button @click="hanldClick"&gt;子组件使用$emit发送数据，父组件使用$once监听只能触发一次&lt;/button&gt; &lt;/div&gt;` &#125; var vm = new Vue(&#123; el:"#app", data:&#123; msg:'', count:0 &#125;, components:&#123; 'children-component':children &#125;, methods:&#123; aa(s)&#123; console.log(s) &#125;, removeClick()&#123; bus.$off('aa') &#125; &#125;, mounted()&#123; bus.$on('aa',(val)=&gt;&#123; this.msg = val this.count++ &#125;) bus.$once('bb',(val)=&gt;&#123; console.log(val) &#125;) &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue中$emit/$on/$once/$off的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在mac appstor下载软件提示内存不足问题]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%9C%A8mac%20app%20store%E4%B8%8B%E8%BD%BD%E8%BD%AF%E4%BB%B6%E6%8F%90%E7%A4%BA%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[日积月累 time machine搞的鬼。你原来空间不足时，但time machine存储的是你的“过去”你只禁用掉time machine，再删除time machine时间点就可以了，另外可以运行电脑一两天，也有可能就好了。你在关于存储空间中显示的不是真实值，用df -h查看才是真实的。只要运行sudo tmutil listlocalsnapshots /查看有还存储了那些time machine，再用下面的命令删除掉就可以了。]]></content>
      <categories>
        <category>用机小技巧</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo的基本操作]]></title>
    <url>%2F2019%2F07%2F09%2Fhexo%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[记录一下hexo的基本操作 hexo clean =&gt; hexo s =&gt; 创建 hexo new “title” hexo clean（清除） =&gt; hexo g（生成） =&gt; gulp（压缩打包） =&gt; hexo d（部署git）]]></content>
      <categories>
        <category>hexo的使用</category>
      </categories>
      <tags>
        <tag>hexo的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue双向绑定实现原理]]></title>
    <url>%2F2019%2F07%2F09%2FVue%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[留下源码以便以后调试回忆 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="text"&gt; &#123;&#123; text &#125;&#125; &lt;/div&gt; &lt;script&gt; function observe(obj, vm) &#123; Object.keys(obj).forEach(function (key) &#123; defineReactive(vm, key, obj[key]); &#125;) &#125; function defineReactive(obj, key, val) &#123; var dep = new Dep(); Object.defineProperty(obj, key, &#123; get: function () &#123; // 添加订阅者 watcher 到主题对象 Dep if (Dep.target) dep.addSub(Dep.target); return val &#125;, set: function (newVal) &#123; if (newVal === val) return val = newVal; // 作为发布者发出通知 dep.notify(); &#125; &#125;); &#125; function nodeToFragment(node, vm) &#123; var flag = document.createDocumentFragment(); var child; // 理解了上面这一点，就能理解 while (child = node.firstChild) 这种用法 // 其次，appendChild 方法有个隐蔽的地方，就是调用以后 child 会从原来 DOM 中移除 // 所以，第二次循环时，node.firstChild 已经不再是之前的第一个子元素了 while (child = node.firstChild) &#123; compile(child, vm); flag.appendChild(child); // 将子节点劫持到文档片段中 &#125; return flag &#125; function compile(node, vm) &#123; var reg = /\&#123;\&#123;(.*)\&#125;\&#125;/; // 节点类型为元素 if (node.nodeType === 1) &#123; var attr = node.attributes; // 解析属性 for (var i = 0; i &lt; attr.length; i++) &#123; if (attr[i].nodeName == 'v-model') &#123; var name = attr[i].nodeValue; // 获取 v-model 绑定的属性名 node.addEventListener('input', function (e) &#123; // 给相应的 data 属性赋值，进而触发该属性的 set 方法 vm[name] = e.target.value; &#125;); node.value = vm[name]; // 将 data 的值赋给该 node node.removeAttribute('v-model'); &#125; &#125;; new Watcher(vm, node, name, 'input'); &#125; // 节点类型为 text if (node.nodeType === 3) &#123; if (reg.test(node.nodeValue)) &#123; var name = RegExp.$1; // 获取匹配到的字符串 name = name.trim(); new Watcher(vm, node, name, 'text'); &#125; &#125; &#125; function Watcher(vm, node, name, nodeType) &#123; Dep.target = this; this.name = name; this.node = node; this.vm = vm; this.nodeType = nodeType; this.update(); Dep.target = null; &#125; Watcher.prototype = &#123; update: function () &#123; this.get(); if (this.nodeType == 'text') &#123; this.node.nodeValue = this.value; &#125; if (this.nodeType == 'input') &#123; this.node.value = this.value; &#125; &#125;, // 获取 data 中的属性值 get: function () &#123; this.value = this.vm[this.name]; // 触发相应属性的 get &#125; &#125; function Dep() &#123; this.subs = [] &#125; Dep.prototype = &#123; addSub: function (sub) &#123; this.subs.push(sub); &#125;, notify: function () &#123; this.subs.forEach(function (sub) &#123; sub.update(); &#125;); &#125; &#125; function Vue(options) &#123; this.data = options.data; var data = this.data; observe(data, this); var id = options.el; var dom = nodeToFragment(document.getElementById(id), this); // 编译完成后，将 dom 返回到 app 中 document.getElementById(id).appendChild(dom); &#125; var vm = new Vue(&#123; el: 'app', data: &#123; text: 'hello world', &#125; &#125;) &lt;/script&gt;&lt;/body&gt;]]></content>
      <tags>
        <tag>Vue双向绑定实现原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise的使用]]></title>
    <url>%2F2019%2F05%2F31%2FPromise%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[温故而知新，可以为师矣 ES6 Promise 用法讲解Promise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。 resolve参数（可以理解合格的内容）12345678910111213&lt;script&gt; var p = new Promise(function(resolve,reject)&#123; setTimeout(() =&gt; &#123; console.log('执行完成'); resolve("合格的内容") &#125;,2000) &#125;)&lt;/script&gt;先打印出了Promise &#123;&lt;pending&gt;&#125; __proto__: Promise [[PromiseStatus]]: "resolved" [[PromiseValue]]: "合格的内容"再过2秒，打印出了'执行完成' 使用.then就可以获取resovle中的内容啦123456789101112&lt;script&gt; var p = new Promise(function(resolve,reject)&#123; setTimeout(() =&gt; &#123; console.log('执行完成'); resolve("合格的内容") &#125;,2000) &#125;) p.then( (val) =&gt; &#123; console.log(val) &#125;)&lt;/script&gt;2秒钟后就相继输出了 "执行完成" "合格的内容" resolve参数（可以理解不合格的内容）可以使用.catch获取它的内容123456789101112131415161718192021function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject('数字太大了'); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( val =&gt; &#123; console.log(val)&#125;).catch( val =&gt; &#123; console.log(val)&#125;)如何满足if条件，就输出相应数字，否则输出 reject中的'数字太大了' all的用法 方法都调用完成再输出resolve中的内容 12345678910111213141516171819202122232425262728293031323334353637function runAsync1()&#123;var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务1执行完成'); resolve('随便什么数据1'); &#125;, 1000);&#125;);return p; &#125;function runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务2执行完成'); resolve('随便什么数据2'); &#125;, 2000); &#125;); return p; &#125;function runAsync3()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务3执行完成'); resolve('随便什么数据3'); &#125;, 300); &#125;); return p; &#125;Promise.all([runAsync1(),runAsync2(),runAsync3()]) //时间短的先执行.then(function(results)&#123; console.log(results); //返回值按照数据中方法顺序输出&#125;);// 异步任务3执行完成 异步任务1执行完成 异步任务2执行完成// ["随便什么数据1", "随便什么数据2", "随便什么数据3"] race的用法 异步执行最快的函数以后，直接输出内容，再按照执行速度依次执行 123456789101112131415161718192021222324252627282930313233343536function runAsync1()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务1执行完成'); resolve('随便什么数据1'); &#125;, 3000); &#125;); return p; &#125;function runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务2执行完成'); resolve('随便什么数据2'); &#125;, 3000); &#125;); return p; &#125;function runAsync3()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log('异步任务3执行完成'); resolve('随便什么数据3'); &#125;, 1000); &#125;); return p; &#125;Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;);//异步任务3执行完成 随便什么数据3 异步任务1执行完成 异步任务2执行完成]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Promise的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue中slot的使用（通俗易懂）]]></title>
    <url>%2F2019%2F04%2F22%2Fslot%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[slot 好久没更新博客啦，今天我又回来啦！ 为什么会出现插槽我们经常需要向一个组件传递内容，像这样： 123&lt;alert-box&gt; Something bad happened&lt;/alert-box&gt; 但是现实却是很残酷，可能会给你来个Error!Something bad happened 好啦，我们可以进入正题啦！😜 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id="app"&gt; &lt;childer-component :items="items"&gt; &lt;h2&gt;单个插槽&lt;/h2&gt; &lt;span&gt;只有在子组件使用单个插槽 slot 才能让我显示出来&lt;/span&gt; &lt;h2&gt;多个插槽也叫具名插槽&lt;/h2&gt; &lt;div slot="one"&gt; &lt;span&gt;one&lt;/span&gt; &lt;span&gt;第一个&lt;/span&gt; &lt;/div&gt; &lt;div slot="two"&gt; &lt;span&gt;two&lt;/span&gt; &lt;span&gt;第二个&lt;/span&gt; &lt;/div&gt; &lt;h2&gt;作用域插槽（将子组件的值传到父组件供使用）&lt;/h2&gt; &lt;div slot-scope="props"&gt; &lt;span&gt;&#123;&#123; props.addr &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; props.cname &#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123; props.age &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/childer-component&gt;&lt;/div&gt;&lt;script&gt; var childerComponent = Vue.component('childer-component',&#123; props:['items'], template:` &lt;div&gt; &lt;h1&gt;我是子组件&lt;/h1&gt; &lt;slot&gt;默认&lt;/slot&gt; &lt;slot name="one"&gt;&lt;/slot&gt; &lt;slot name="two"&gt;&lt;/slot&gt; &lt;slot :cname="items[2].cname"&gt;&lt;/slot&gt; &lt;slot :addr="items[2].addr"&gt;&lt;/slot&gt; &lt;slot age="18"&gt;&lt;/slot&gt; &lt;/div&gt; ` &#125;) var vm = new Vue(&#123; el: '#app', data: &#123; items:[ &#123; text:'文字1' , cname:'tom' , addr:'usa' &#125;, &#123; text:'文字2' , cname:'wangwu' , addr:'uk' &#125;, &#123; text:'文字3' , cname:'zhangsan' , addr:'un' &#125; ], components:&#123; 'childerComponent':childerComponent, &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>slot的使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究call 和 apply 的原理]]></title>
    <url>%2F2019%2F02%2F18%2F%E6%8E%A2%E7%A9%B6call-%E5%92%8C-apply-%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[音乐🎵搭配学习更美味哦！ 建议看这片文章时可以点击音乐🎵，来个单曲循，美滋滋 先拿call开刀 作用：call和apply都是替换函数内错误的this 1234567var a = &#123; value:1&#125;var b = function()&#123; console.log(this.value) // 如果不对this进行绑定执行bar() 会返回undefined&#125;b.call(a) //1 去除繁琐的讲解，一步到位自己模拟call的用法写一个函数，达到相同目的 1234567891011121314151617Function.prototype.myCall = function(context)&#123; var context = context || window; //当没传入值时候，就是指全局window context.fn = this; //把调用myCall前的方法缓存下来 var args = [...arguments].slice(1);//使用...打散传入值，并去除第一方法，得到一个数组 var result = context.fn(...args);//把数组打散，把dinging 18传入b方法中 delete context.fn; //删除 return result&#125;var a = &#123; value:1&#125;var b = function(name,age)&#123; console.log(this.value) console.log(name) console.log(age)&#125;b.myCall(a,"dingding",18) apply apply的方法和 call 方法的实现类似，只不过是如果有参数，以数组形式进行传递 apply这个API平时使用的场景，代码如下:123456789var a = &#123; value:1&#125;var b = function(name,age)&#123; console.log(this.value) console.log(name) console.log(age)&#125;b.apply(a,["dingding",18]) 直接上模拟apply功能代码123456789101112131415161718192021Function.prototype.myApply = function(context)&#123; var context = context || window; context.fn = this; var result; if(arguments[1])&#123; result = context.fn(...arguments[1]) &#125;else&#123; result = context.fn() &#125; delete context.fn return result&#125;var a = &#123; value:1&#125;var b = function(name,age)&#123; console.log(this.value) console.log(name) console.log(age)&#125;b.myApply(a,["dingding",18]) 参考资料]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>探究call 和 apply 的原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片懒加载]]></title>
    <url>%2F2019%2F02%2F14%2F%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[LazyLoad 懒加载的意义这里‘懒’的意思可以理解为延迟，如淘宝、京东这些电商平台有大量的图片，如果上来就加载服务器表示压力山大，所以就想出了懒加载这种克敌之法，用户滚动到的区域才发送请求加载内容 原理将页面中的img标签src指向一张小照片或者为空都可以，然后写一个自定义属性比如（data-src）指向正确的图片，其实就是用正确的照片替换src里面的照片 代码在写代码前，需要了解各种高度。先看这篇文章js坐标位置1234567891011121314151617181920212223 &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; img &#123; display: block; margin-bottom: 50px; width: 400px; height: 400px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src="" data-src="http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg" alt=""&gt; &lt;img src="" data-src="http://ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/3c6d55fbb2fb43161361e1432ba4462309f7d389.jpg" alt=""&gt; &lt;img src="" data-src="http://pic.58pic.com/58pic/15/68/59/71X58PICNjx_1024.jpg" alt=""&gt; &lt;img src="" data-src="http://qimg.hxnews.com/2019/0128/1548663985785.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/242dd42a2834349bf8d014a3c3ea15ce37d3bec6.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/d439b6003af33a87089f4704cc5c10385343b53a.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/38dbb6fd5266d01607666e0b9d2bd40735fa3591.jpg" alt=""&gt; &lt;img src="" data-src="http://imgsrc.baidu.com/imgad/pic/item/d043ad4bd11373f02f236d8cae0f4bfbfbed0480.jpg" alt=""&gt;&lt;/body&gt; javascript1234567891011121314151617var num = document.getElementsByTagName('img').length;var img = document.getElementsByTagName("img");var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历lazyload(); //页面载入完毕加载可是区域内的图片window.onscroll = lazyload;function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125;&#125; 使用节流函数进行性能优化如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。我想实现限制触发频率，来优化性能。 节流函数：只允许一个函数在N秒内执行一次。下面是一个通俗易通的节流函数：1234567891011121314151617181920212223242526var num = document.getElementsByTagName('img').length;var img = document.getElementsByTagName("img");var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历resizehandler(); //页面载入完毕加载可是区域内的图片n=0;function resizehandler()&#123; var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125;&#125;function throttle(method,context)&#123; clearTimeout(method.tId); method.tId=setTimeout(function()&#123; method.call(context); &#125;,500);&#125;window.onscroll=function()&#123; throttle(resizehandler,window);&#125; 函数节流方案以下三种时间戳方案1234567891011121314151617181920212223242526272829 var num = document.getElementsByTagName('img').length; var img = document.getElementsByTagName("img"); var n = 0; //存储图片加载到的位置，避免每次都从第一张图片开始遍历 lazyload(); //页面载入完毕加载可是区域内的图片 function lazyload() &#123; //监听页面滚动事件 var seeHeight = document.documentElement.clientHeight; //可见区域高度 var scrollTop = document.documentElement.scrollTop || document.body.scrollTop; //滚动条距离顶部高度 for (var i = n; i &lt; num; i++) &#123; if (img[i].offsetTop &lt; seeHeight + scrollTop) &#123; if (img[i].getAttribute("src") == "") &#123; img[i].src = img[i].getAttribute("data-src"); &#125; n = i + 1; &#125; &#125; &#125;--------------------------------- 以上代码不在重复 -------------------------------- var throttle = function(fun,delay)&#123; var perv = Date.now(); return function()&#123; var context = this; var now = Date.now(); if (now-perv &gt;= delay)&#123; fun.apply(context,arguments) prev = Date.now(); &#125; &#125; &#125; window.addEventListener('scroll',throttle(lazyload,1000)) 定时器方案12345678910111213var throttle = function(fun,delay)&#123; var timer = null; return function()&#123; var context = this; if(!timer)&#123; timer = setTimeout(function()&#123; fun.apply(context,arguments) timer = null &#125;,delay) &#125; &#125;&#125;window.addEventListener('scroll',throttle(lazyload,1000)) 时间戳+定时器方案123456789101112131415161718var throttle = function(fun,delay)&#123; var timer = null; var startTime = Date.now(); return function() &#123; var curTime = Date.now(); var remaining = delay - (curTime - startTime); var context = this; var args = arguments; clearTimeout(timer); if (remaining &lt;= 0) &#123; fun.apply(context, args); startTime = Date.now(); &#125; else &#123; timer = setTimeout(fun, remaining); &#125; &#125;&#125;window.addEventListener('scroll',throttle(lazyload,1000))]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>图片懒加载</tag>
        <tag>函数节流3种方式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取事件坐标位置]]></title>
    <url>%2F2019%2F02%2F14%2Fjs%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%9D%90%E6%A0%87%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[心有猛虎，细嗅蔷薇 关于scrollTop,offsetTop,scrollLeft,offsetLeft用法介绍12345678910111213页可见区域宽： document.body.clientWidth;网页可见区域高： document.body.clientHeight;网页可见区域宽： document.body.offsetWidth (包括边线的宽);网页可见区域高： document.body.offsetHeight (包括边线的宽);网页正文全文宽： document.body.scrollWidth;网页正文全文高： document.body.scrollHeight;网页被卷去的高： document.body.scrollTop;网页被卷去的左： document.body.scrollLeft;网页正文部分上： window.screenTop;网页正文部分左： window.screenLeft;屏幕分辨率的高： window.screen.height;屏幕分辨率的宽： window.screen.width;屏幕可用工作区高度： window.screen.availHeight; 事件坐标事件1.相对于显示屏左上角:e.screenX,e.screenY2.相对于文档显示区左上角:e.clientX,e.clientY3.相对于div左上角:e.offsetX,e.offsetY 页面滚动事件window.onscroll 当页面滚动时触发 获取滚动距离：document.body.scrollTop | | document.documentElement.scrollTop 主动控制页面的滚动位置： window.scrollTo（横向滚动到的位置，纵向滚动到的位置） window.scrollBy(横向滚动的距离，纵向滚动的距离) 参考资料搞清clientHeight、offsetHeight、scrollHeight、offsetTop、scrollTop]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>screenX/screenY</tag>
        <tag>clientX/slientY</tag>
        <tag>offsetX/offsetY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习之神经网络]]></title>
    <url>%2F2019%2F02%2F04%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B9%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[今天是19年除夕夜 神经网络参考视频 神经元————最小的神经网络 总结太枯燥看不下去了 😂]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链理论和代码演示]]></title>
    <url>%2F2019%2F02%2F03%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[一场没有诗和远方，全是苟且的演讲 无意间看晓说，他说5G对以后的影响，其中有个数据分发使用了比特币技术，对此查阅资料及视频进行学习，以下为个人总结参考资料如何 晓说视频 讲解区块链原理视频 区块链代码实现视频 以太坊开源代码 以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。 区块链基本原型 区块链本质就是 分布式数据库 区块链是 公开的数据库，不是私人的数据库 区块链是加密货币和智能合约的基础 解决去中心问题问：如何快速验证哪个数据才是正确的？答：每次交易都记录 序号/时间戳/hash值，形成一个区块链，和其他区块进行对比 如何确定使用权。问：账户所有权问题 答：地址是用公钥通过hash值生成的，值再进行Base58进行编码的值,谁用这个地址支付，谁就拥有这个地址的所有权,谁有这个私钥，谁就能用这个地址支付，丢失私钥就是丢失使用权不能补办 使用go语言模拟区块链技术基本原理 挖矿的本质使用计算机计算，前面连续都是零的一串，记录交易信息的特殊的hash值生产的编码]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链理论和代码演示</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs源码解析]]></title>
    <url>%2F2019%2F01%2F31%2FVuejs%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[除了使用vue工具，更想揭开神秘面纱,开始一场神秘之旅吧 vue.js源码地址 看后感觉内容不错的参考资料1.Vue技术内幕 从一个简单的example开始12345678&lt;div id="app"&gt;&#123;&#123;test&#125;&#125;&lt;/div&gt;var vm = new Vue(&#123;el: '#app',data: &#123; test: 1 &#125;&#125;) 这段代码简单调用了Vue，传递了两个选项 el 和 data,这段代码在页面呈现的DOM如下:1&lt;div id="app"&gt;1&lt;div&gt; 接下来我们看看上面的例子到底发生了什么？首先当我们使用Vue构造函数的时候，第一句执行的代码到底是什么，所以我们找到Vue的构造函数，Vue的构造函数在core/instance/index.js 12345678function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; 上面的代码一目了然，当new Vue构造函数时，执行的第一句代码时this._init(options)方法，options参数内容是我们调用Vue构造函数传入的 123456options = &#123; el:'#app', data:&#123; test:1 &#125;&#125; 既然如此我们就找到 _init方法，_init 方法在 src/core/instance/init.js 文件被添加到 Vue 的原型上，下面我们就看看 _init 做了什么。_init 方法的一开始，是这两句代码：123const vm: Component = this// a uidvm._uid = uid++ 首先声明了一个常量vm，并且在vm上添加了一个属性 _uid，uid的初始值是0每次实例化一个 Vue 实例之后，uid 的值都会 ++。 接下去的代码如下1234567let startTag, endTag/* istanbul ignore if */if (process.env.NODE_ENV !== 'production' &amp;&amp; config.performance &amp;&amp; mark) &#123; startTag = `vue-perf-start:$&#123;vm._uid&#125;` endTag = `vue-perf-end:$&#123;vm._uid&#125;` mark(startTag)&#125; 首先声明了startTag, endTag这两个参数(parameter)，其中if括号中的意思是：在非生产环境下，并且config.performance和mark都为真，才执行里面的代码，其中 config.performance 来自于 core/config.js 文件，我们知道，Vue.config 同样引用了这个对象，在 Vue 的官方文档中可以看到如下内容：Vue 提供了全局配置 Vue.config.performance，我们通过将其设置为 true，即可开启性能追踪 你可以追踪四个场景的性能1、组件初始化(component init)2、编译(compile)，将模板(template)编译成渲染函数3、渲染(render)，其实就是渲染函数的性能，或者说渲染函数执行且生成虚拟DOM(vnode)的性能4、打补丁(patch)，将虚拟DOM渲染为真实DOM的性能]]></content>
  </entry>
  <entry>
    <title><![CDATA[vue中diff算法详解]]></title>
    <url>%2F2019%2F01%2F30%2Fvue-diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[可以先看Vuejs运行机制 当数据发生变化时，vue是怎么更新节点的？要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。 我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。 diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。 virtual DOM和真实DOM的区别？virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：123456789101112 &lt;div&gt; &lt;p&gt;123&lt;/p&gt; &lt;/div&gt;对应的virtual DOM（伪代码）： var Vnode = &#123; tag: 'div', children: [ &#123; tag: 'p', text: '123' &#125; ] &#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） diff的比较方式？在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图： diff流程图当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图 具体分析patch来看看patch是怎么打补丁的（代码只保留核心部分）123456789101112131415161718function patch (oldVnode,vnode)&#123; //some code if(sameVnode(oldVnode,vnode))&#123; patchVnode(oldVnode,vnode) &#125;else&#123; const oEl = oldVnode.el //当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) //父元素 createEle(vnode) //根据Vnode生成新元素 if (parentEle !== null) &#123; // 将新元素添加进父元素 api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null &#125; &#125; // some code return vnode&#125; patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode12345678910function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )&#125; 不值得比较则用Vnode替换oldVnode如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…其实没这么简单，它利用闭包有个缓存机制） patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？1234567891011121314151617 patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125; 这个函数做了以下事情： 找到对应的真实dom，称为el判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。如果oldVnode有子节点而Vnode没有，则删除el的子节点如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要其他几个点都很好理解，我们详细来讲一下updateChildren updateChildren123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方 如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后 如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，那么遍历oldChild，S挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将S对应的节点插入到dom中对应的oldS位置，oldS和S指针向中间移动。 第一步 oldS = a, oldE = d； S = a, E = b; oldS和S匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d第二步 oldS = b, oldE = d； S = c, E = b; oldS和E匹配，就将原本的b节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，此时dom的位置为：a d b第三步 oldS = d, oldE = d； S = c, E = d; oldE和E匹配，位置不变此时dom的位置为：a d b第四步 oldS++; oldE--; oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b一次模拟完成。这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据index添加到dom中去（如上图） S &gt; E表示vCh先遍历完，那么就在真实dom中将区间为[oldS, oldE]的多余节点删掉 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode)&#125; 就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue的diff算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 内部运行机制]]></title>
    <url>%2F2019%2F01%2F30%2Fvue-source-code%2F</url>
    <content type="text"><![CDATA[生活的全部意义在于无穷地探索尚未知道的东西，在于不断地增加更多的知识。————左拉 原文地址 全局概览这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。 首先我们来看一下笔者画的内部流程图。大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。 初始化及挂载在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」，后面会详细讲到，这里只要有一个印象即可。 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。 编译compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。 parseparse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。 optimizeoptimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。 generategenerate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。 在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。 响应式接下来也就是 Vue.js 响应式核心部分。 这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。 Virtual DOM我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 比如说下面这样一个例子： { tag: &apos;div&apos;, /*说明这是一个div标签*/ children: [ /*存放该标签的子节点*/ { tag: &apos;a&apos;, /*说明这是一个a标签*/ text: &apos;click me&apos; /*标签的内容*/ } ] } 渲染后可以得到 &lt;div&gt; &lt;a&gt;click me&lt;/a&gt; &lt;/div&gt; 这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。 更新视图前面我们说到，在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。 那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。 再看全局回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Vue.js 内部运行机制</tag>
        <tag>patch</tag>
        <tag>render function</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp和webpack区别]]></title>
    <url>%2F2019%2F01%2F29%2Fgulp%E5%92%8Cwebpack%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[我愿化身石桥，受五百年风吹，五百年日晒，五百年雨淋，只求她从桥上经过 原文地址 gulpgulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：简单说就一个Task Runner webpackwebpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。PS：webpack is a module bundle 相同功能gulp与webpack可以实现一些相同功能，如下（列举部分）： 功能 gulp webpack 文件合并与压缩（css） 使用gulp-minify-css模块 样式合并一般用到extract-text-webpack-plugin插件压缩则使用webpack.optimize.UglifyJsPlugin 文件合并与压缩（js） 使用gulp-uglify和gulp-concat两个模块 js合并在模块化开始就已经做,压缩则使用webpack.optimize.UglifyJsPlugin sass/less预编译 使用gulp-sass/gulp-less 模块 sass-loader/less-loader 进行预处理 启动server 使用gulp-webserver模块 使用webpack-dev-server模块 版本控制 使用gulp-rev和gulp-rev-collector两个模块 将生成文件加上hash值 module.exports = {plugins:[new ExtractTextPlugin(style.[hash].css”)} 两者区别 虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。 gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。 webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。 总结 gulp应该与grunt比较，而webpack应该与browserify（网上太多资料就这么说，这么说是没有错，不过单单这样一句话并不能让人清晰明了）。 gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>gulp和webpack区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模块化编程弄懂CommonJS和AMD/CMD！]]></title>
    <url>%2F2019%2F01%2F28%2FCommonJs-AMD-CMD%2F</url>
    <content type="text"><![CDATA[为什么模块很重要？ 因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！ 原文链接 CommonJS 一开始大家都认为JS是辣鸡，没什么用，官方定义的API只能构建基于浏览器的应用程序，逗我呢，这太狭隘了吧(用了个高端词，嘎嘎)，CommonJS就按耐不住了，CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序： (1).服务器端JavaScript应用程序(2).命令行工具(3).图形界面应用程序(4).混合应用程序（如，Titanium或Adobe AIR） 2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。 node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。 var math = require(‘math’); 然后，就可以调用模块提供的方法： var math = require(‘math’); math.add(2,3); // 5 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。 虽说Node遵循CommonJS的规范，但是相比也是做了一些取舍，填了一些新东西的。 不过，说了CommonJS也说了Node，那么我觉得也得先了解下NPM了。NPM作为Node的包管理器，不是为了帮助Node解决依赖包的安装问题嘛，那它肯定也要遵循CommonJS规范啦，它遵循包规范（还是理论）的。CommonJS WIKI讲了它的历史，还介绍了modules和packages等。 下面讲讲commonJS的原理以及简易实现： 原理浏览器不支持CommonJS原因，在于缺少四个Node.js环境变量 module exports require global只要能提供这4个变量，浏览器就能加载CommonJS模块下面一个简单示例 var module = { exports : {} }; (function(module,exports){ exports.multiply = function(n){return n*100} }(module,module.exports)) var f = module.exports.multiply; f(5) // 500 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。 Browserify 的实现知道了原理，就能做出工具了。Browserify 是目前最常用的 CommonJS 格式转换的工具。 请看一个例子，main.js 模块加载 foo.js 模块。 12345678// foo.jsmodule.exports = function(x) &#123;console.log(x);&#125;;// main.jsvar foo = require(&quot;./foo&quot;);foo(&quot;Hi&quot;); 使用下面的命令，就能将main.js转为浏览器可用的格式。 $ browserify main.js &gt; compiled.jsBrowserify到底做了什么？安装一下browser-unpack，就能看清楚了。$ npm install browser-unpack -g然后，将前面生成的compile.js解包。 $ browser-unpack &lt; compiled.js 12345678910111213[ &#123; &quot;id&quot;:1, &quot;source&quot;:&quot;module.exports = function(x) &#123;\n console.log(x);\n&#125;;&quot;, &quot;deps&quot;:&#123;&#125; &#125;, &#123; &quot;id&quot;:2, &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;, &quot;deps&quot;:&#123;&quot;./foo&quot;:1&#125;, &quot;entry&quot;:true &#125;] 可以看到，browerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。 因为main.js加载了foo.js,所以deps属性就指定./foo对应1号模块。执行时候，浏览器遇到require(./foo)语句，就自动执行1好模块的source属性，并将执行后module.exports属性值输出 Tiny Browser Require虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。我根据 mocha 的内部实现，做了一个纯浏览器的 CommonJS 模块加载器 tiny-browser-require 。完全不需要命令行，直接放进浏览器即可，所有代码只有30多行。 它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。123456789101112131415161718192021222324252627282930313233343536373839404142 function require(p)&#123; var path = require.resolve(p); //node.js语法加载当前模块目录下的绝对路径 var mod = require.modules[path]; if (!mod) throw new Error(&apos;failed to require &quot;&apos; + p + &apos;&quot;&apos;); if (!mod.exports) &#123; mod.exports = &#123;&#125;; mod.call(mod.exports, mod, mod.exports, require.relative(path)); &#125; return mod.exports;&#125;require.modules = &#123;&#125;;require.resolve = function (path)&#123; var orig = path; var reg = path + &apos;.js&apos;; var index = path + &apos;/index.js&apos;; return require.modules[reg] &amp;&amp; reg || require.modules[index] &amp;&amp; index || orig;&#125;;require.register = function (path, fn)&#123; require.modules[path] = fn;&#125;;require.relative = function (parent) &#123; return function(p)&#123; if (&apos;.&apos; != p.charAt(0)) return require(p); var path = parent.split(&apos;/&apos;); var segs = p.split(&apos;/&apos;); path.pop(); for (var i = 0; i &lt; segs.length; i++) &#123; var seg = segs[i]; if (&apos;..&apos; == seg) path.pop(); else if (&apos;.&apos; != seg) path.push(seg); &#125; return require(path.join(&apos;/&apos;)); &#125;;&#125;;使用的时候，先将上面的代码放入页面。然后，将模块放在如下的立即执行函数里面，就可以调用了。 &lt;script src=&quot;require.js&quot; /&gt; &lt;script&gt; require.register(&quot;moduleId&quot;, function(module, exports, require){ // Module code goes here }); var result = require(&quot;moduleId&quot;); &lt;/script&gt; 还是以前面的 main.js 加载 foo.js 为例。 require.register(&quot;./foo.js&quot;, function(module, exports, require){ module.exports = function(x) { console.log(x); }; }); var foo = require(&quot;./foo.js&quot;); foo(&quot;Hi&quot;); 注意，这个库只模拟了 require 、module 、exports 三个变量，如果模块还用到了 global 或者其他 Node 专有变量（比如 process），就通过立即执行函数提供即可。 AMD基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上面的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？ var math = require(‘math’);math.add(2, 3); 第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。您会注意到 require 是同步的。 这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 CommonJS是主要为了JS在后端的表现制定的，他是不适合前端的，AMD(异步模块定义)出现了，它就主要为前端JS的表现制定规范。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：123require([&apos;math&apos;], function (math) &#123; math.add(2, 3); &#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。 RequireJS就是实现了AMD规范的呢。详细概括：下面以RequireJS为例说明AMD规范 为什么要用require.js？最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。123456&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;这段代码依次加载多个js文件。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 require.js的诞生，就是为了解决这两个问题： (1) 实现js文件的异步加载，避免网页失去响应；(2) 管理模块之间的依赖性，便于代码的编写和维护。 require.js的加载使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。 &lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： &lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 主模块的写法上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。下面就来看，怎么写main.js。如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。 // main.js alert(“加载成功！”); 但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 // main.js require([‘moduleA’, ‘moduleB’, ‘moduleC’], function (moduleA, moduleB, moduleC){ // some code here }); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 下面，我们看一个实际的例子。假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写： require([‘jquery’, ‘underscore’, ‘backbone’], function ($, _, Backbone){ // some code here }); require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块的加载上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 require.config({ paths: { “jquery”: “jquery.min”, “underscore”: “underscore.min”, “backbone”: “backbone.min” } }); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。 require.config({ paths: { “jquery”: “lib/jquery.min”, “underscore”: “lib/underscore.min”, “backbone”: “lib/backbone.min” } }); 另一种则是直接改变基目录（baseUrl）。 require.config({ baseUrl: “js/lib”, paths: { “jquery”: “jquery.min”, “underscore”: “underscore.min”, “backbone”: “backbone.min” } }); 如果某个模块在另一台主机上，也可以直接指定它的网址，比如： require.config({ paths: { “jquery”: “https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot; } }); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 AMD模块的写法require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写： // math.js define(function (){ var add = function (x,y){ return x+y; }; return { add: add }; }); 加载方法如下： // main.js require([‘math’], function (math){ alert(math.add(1,1)); }); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 define([‘myLib’], function(myLib){ function foo(){ myLib.doSomething(); } return { foo : foo }; }); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 加载非规范的模块理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？ 回答是可以的。 这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。 require.config({ shim: { ‘underscore’:{ exports: ‘_’ }, ‘backbone’: { deps: [‘underscore’, ‘jquery’], exports: ‘Backbone’ } } }); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。 比如，jQuery的插件可以这样定义： shim: { ‘jquery.scroll’: { deps: [‘jquery’], exports: ‘jQuery.fn.scroll’ } } require.js插件require.js还提供一系列插件，实现一些特定的功能。 domready插件，可以让回调函数在页面DOM结构加载完成后再运行。 require([‘domready!’], function (doc){ // called once the DOM is ready }); text和image插件，则是允许require.js加载文本和图片文件。 define([ ‘text!review.txt’, ‘image!cat.jpg’ ], function(review,cat){ console.log(review); document.body.appendChild(cat); } ); 类似的插件还有json和mdown，用于加载json文件和markdown文件。（完） 另一个人的概括(有点简单)： AMD就只有一个接口：define(id?,dependencies?,factory); 它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样： define([‘dep1’,’dep2’],function(dep1,dep2){…}); 要是没什么依赖，就定义简单的模块，下面这样就可以啦： define(function(){ var exports = {}; exports.method = function(){...}; return exports; }); 咦，这里有define，把东西包装起来啦，那Node实现中怎么没看到有define关键字呢，它也要把东西包装起来呀，其实吧，只是Node隐式包装了而已….. 这有AMD的WIKI中文版，讲了很多蛮详细的东西，用到的时候可以查看：AMD的WIKI中文版 CMD大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版，应有尽有：seajs官方doc define(function(require,exports,module){…}); 用过seajs吧，这个不陌生吧，对吧。 前面说AMD，说RequireJS实现了AMD，CMD看起来与AMD好像呀，那RequireJS与SeaJS像不像呢？ 虽然CMD与AMD蛮像的，但区别还是挺明显的，官方非官方都有阐述和理解，我觉得吧，说的都挺好： 官方阐述SeaJS与RequireJS异同 SeaJS与RequireJS的最大异同（这个说的也挺好)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CommonJS/AMD/CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 JavaScript 和 Emoji 做地址栏动画]]></title>
    <url>%2F2019%2F01%2F27%2FEmojis-url%2F</url>
    <content type="text"><![CDATA[同样是9年义务教育，你为何这么优秀 译者：Wpeach 原文作者：Matthew Rayfield 原文地址：Animating URLs with Javascript and Emojis 你可以在地址栏使用 emoji（和其它图形 unicode 字符），这看着很棒，但是好像没人这么做，为什么呢？也许 emoji 对于正常的网络平台来说太过异国情调了？或许是他们因为害怕不利于SEO？不管什么原因，维恩图中的合理性观点“没人这么做，但这是可能的”是让我兴奋的点。所以我决定花费一些时间研究在地址栏中图形字符的可能性，特别是通过 JavaScript 给这些字符加上动画。循环动画首先，确保你页面的 JavaScript 代码是 UTF-8 编码，否则无法在你的代码中显示 emoji，这可以通过设置 HTTP 头部或页面的 META 标签来实现。你很可能不用担心这个，但你可以在这里找到更多信息：Unicode in Javascript by Flavio。为了达到我们想要的效果，让 emoji 像小仙女一样在地址栏里偏偏起舞，我们需要一个循环，实际上，我们所需要的只是一个循环，我们启动这个循环，它不断循环，我们的目的就达到了。这是我们的第一个循环动画，一个旋转的emoji 月亮。我猜当他们添加这个 emoji 序列时，也有这个想法吧？ var f = [&apos;🌑&apos;, &apos;🌒&apos;, &apos;🌓&apos;, &apos;🌔&apos;, &apos;🌝&apos;, &apos;🌖&apos;, &apos;🌗&apos;, &apos;🌘&apos;]; function loop() { location.hash = f[Math.floor((Date.now()/100)%f.length)]; setTimeout(loop, 50); } loop(); 复制代码运行代码，你可以在地址栏看到此循环的结果。如果你不喜欢旋转的月亮，你可以选择任何你喜欢的 emoji 来替换这个数组，比如一个时钟： var f = [‘🕐’,’🕑’,’🕒’,’🕓’,’🕔’,’🕕’,’🕖’,’🕗’,’🕘’,’🕙’,’🕚’,’🕛’];复制代码这是一个非常简单的例子，真的非常简单，所以我们来升级一下循环，让它显示一串 emoji ! 这次我们使用 emoji 的skin tone modifiers肤色调节属性来制作一些变色宝宝： var e = [&apos;🏻&apos;, &apos;🏼&apos;, &apos;🏽&apos;, &apos;🏾&apos;, &apos;🏿&apos;]; function loop() { var s = &apos;&apos;, i, m; for (i = 0; i &lt; 10; i ++) { m = Math.floor(e.length * ((Math.sin((Date.now()/100) + i)+1)/2)); s += &apos;👶&apos; + e[m]; } location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我们可以使用时间和位置控制的正弦波来选择我们想要的颜色，这给了我们一个很好的颜色变幻效果！比如我们再来一次月亮旋转，使它展开，制作一个类似于加载条的动画？好的，开始实现： var f = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;, &apos;🌔&apos;, &apos;🌓&apos;, &apos;🌒&apos;], d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], m = 0; function loop() { var s = &apos;&apos;, x = 0; if (!m) { while (d[x] == 4) { x ++; } if (x &gt;= d.length) m = 1; else { d[x] ++; } } else { while (d[x] == 0) { x ++; } if (x &gt;= d.length) m = 0; else { d[x] ++; if (d[x] == 8) d[x] = 0; } } d.forEach(function (n) { s += f[n]; }); location.hash = s; setTimeout(loop, 50); } loop(); 复制代码探索其它字符不止是 emoji 给我们提供了一种在地址栏显示图形的方法，我们的目标中也有一些 unicode 字符。特别有趣的是 框线字符: 它们中很多更适合二维输出，但它们在一维输出也很棒，例如，我们可以创建一个多个高度变化的块字符串，并构造一个漂亮的小波浪动画： function loop() { var i, n, s = &apos;&apos;; for (i = 0; i &lt; 10; i++) { n = Math.floor(Math.sin((Date.now()/200) + (i/2)) * 4) + 4; s += String.fromCharCode(0x2581 + n); } window.location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我非常喜欢它的效果，我把它永久放在了 wavyurl.com 上。使用可变宽度字符，我们甚至在水平方向上摆动，创建类似于进度条的东西： function loop() { var s = &apos;&apos;, p; p = Math.floor(((Math.sin(Date.now()/300)+1)/2) * 100); while (p &gt;= 8) { s += &apos;█&apos;; p -= 8; } s += [&apos;⠀&apos;,&apos;▏&apos;,&apos;▎&apos;,&apos;▍&apos;,&apos;▌&apos;,&apos;▋&apos;,&apos;▊&apos;,&apos;▉&apos;][p]; location.hash = s; setTimeout(loop, 50); } 复制代码进度条？这看起来，还是有用的，这让我想到了……在地址栏显示视频进度为了增加我们小实验的可能性，我提出了在地址栏中显示网络视频进度的想法。我只需附加一个函数，将我们的进度字符串定义在视频的timeupdate事件中，瞧！地址栏中的视频进度条包含时间和持续时间！ var video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, l = 15, p = Math.floor(video.currentTime / video.duration * (l-1)), i; for (i = 0; i &lt; l; i ++) { if (i == p) s +=&apos;◯&apos;; else if (i &lt; p) s += &apos;─&apos;; else s += &apos;┄&apos;; } location.hash = &apos;╭&apos;+s+&apos;╮&apos;+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码我比较喜欢这个线条和圆组成的进度条，如果你喜欢别的 emoji 比如月亮，我也能让你满意： var e = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;], video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, c = 0, l = 10, p = Math.floor(video.currentTime / video.duration * ((l*5)-1)), i; while (p &gt;= 5) { s += e[4]; c ++; p -= 5; } s += e[p]; c ++; while (c &lt; l) { s += e[0]; c ++; } location.hash = s+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码好的，将此进度条称为“有用”的延伸。 只瞄一眼，我也可以看到在视频分享 URL 中的进度。 与YouTube一样，你可以选择在特定时间创建指向视频的链接，添加视觉指示是不是很酷？嗯？也许我还没有提出一些更有用的“技术”实现，我会继续思考这个问题。 嘿，也许你可以尝试一些东西？最后你可能想知道为什么我使用location.hash =，而不是新且酷的HTML5 History API。 有两个原因：第一个问题是 History API有一个特点：它实际上更改了整个 URL 路径，而不仅仅是 hash。 因此，如果我使用 History API 并将页面更改为/🌑🌘🌗🌖🌕，它看起来会比添加 ＃ 更好。 但这也意味着我的 Web 服务器必须能够响应/🌑🌘🌗🌖🌕，否则如果用户刷新或以其他方式导航到修改后的 URL 将会失败。 这是可行的，但比使用location.hash =更复杂，需要我修改服务器配置。第二个问题有些出乎意料。 实际上，在我测试的3个浏览器中，有2个历史API被限制的。 如果我以极快的速度将我的波形网址推送到地址栏，我最终会在 Chrome 中收到以下错误： Throttling history state changes to prevent the browser from hanging. Safari 给我们提供了更详细的信息： SecurityError: Attempt to use history.pushState() more than 100 times per 30.000000 seconds 现在，如果让我保持在这个限制下也行，但是每秒3帧只是不会影响我目前的动画效果。好孩子 Firefox 似乎并不在乎我推送新历史的次数和速度，这真是想得太周到了。但是，两个主要的浏览器受到影响，加上需要web服务器配置来修复第一个问题，使我更愿意忍受 URL 中的 #。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>用JavaScript和Emoji 做地址栏动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.29.0基本用法]]></title>
    <url>%2F2019%2F01%2F25%2Fwebpack4-29-0%2F</url>
    <content type="text"><![CDATA[不积跬步无以至千里，不积小流无以成江海 准备工作 全局安装webpack和webpack-cli sudo npm install webpack -gsudo npm install webpack-cli -g 文件夹下局部安装 npm init -ysudo npm install webpack –save-devsudo npm install webpack-cli –save-dev 实现对一个js文件打包1234567891011//webpack.config.jsconst path = require(&apos;path&apos;)module.exports = &#123; mode:&apos;development&apos;, entry:&apos;./app.js&apos;, output:&#123; filename:&apos;[name].bundle.js&apos;, path:path.join(__dirname,&apos;./dist&apos;), &#125;&#125;这样就能在dist目录下出现一个app.bundle.js文件啦！ 实现多个js文件打包12345678910111213141516171819//webpack.config.jsconst path = require(&apos;path&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; index: &apos;./src/index.js&apos;, test: &apos;./src/test.js&apos;, test1: &apos;./src/test1.js&apos;, &#125;, output: &#123; path: path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, pubicPath: &apos;http://cdn.con&apos; //请求时会自己加协议（location.protocol=&apos;http&apos;）和端口号(host=&apos;cdn.con&apos;) &#125;， plugins: [ new CleanWebpackPlugin ([&apos;./dist/js&apos;]) //清除之前打包的文件 ]&#125; 使用模版实现每个js对应自己的html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//webpack.config.jsconst path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //模版loaderconst CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; entry:&#123; index:&apos;./src/index.js&apos;, test:&apos;./src/test.js&apos;, test1:&apos;./src/test1.js&apos;, &#125;, output:&#123; path:path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, publicPath:&quot;http://cdn.com&quot; &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: &apos;this a index.html&apos;, //每个html 的title template:&apos;hello.html&apos;, filename:&apos;index.html&apos;, excludeChunks:[&apos;test&apos;,&apos;test1&apos;] //排除名为test.js,test1.js打包的js文件 &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test.html&apos;, excludeChunks:[&apos;index&apos;,&apos;test1&apos;] &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test1.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test1.html&apos;, excludeChunks:[&apos;test&apos;,&apos;index&apos;] &#125;), new CleanWebpackPlugin([&apos;./dist/js&apos;]) ]&#125;//hello.html 模版内容&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.test1.entry.substr (htmlWebpackPlugin.files.publicPath.length)].source() %&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;% for(let k in htmlWebpackPlugin.files.chunks) &#123;%&gt; &lt;% if(k != &apos;index&apos;) &#123;%&gt; &lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks[k].entry %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125;%&gt; &lt;% &#125; %&gt;&lt;/body&gt; 使用file-loader|css-loader|style-loader|postcss-loader1234567891011121314151617181920212223242526272829303132333435//webpack.config.jsmodule.exports = &#123;mode: &apos;development&apos;,entry: &apos;./app.js&apos;,output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.join(__dirname, &apos;./dist/js1&apos;),&#125;,plugins: [ new CleanWebpackPlugin([&apos;./dist/js1&apos;]), require(&apos;autoprefixer&apos;)],module: &#123; rules: [ &#123; test: /\.(le|c)ss$/, test: /\.(png|jpg|gif)$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125;, &#123; loader: &apos;file-loader&apos;&#125;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&quot;autoprefixer&quot;) /*在这里添加*/, ], &#125; &#125; ] &#125; ] &#125;,&#125; 简单打包一个库的演示123456789101112131415161718//webapck.config.jsconst path = require(&apos;path&apos;);module.exports = &#123; mode:&apos;development&apos;, entry: &apos;./src/index.js&apos;, // 不打包进自己写的库的代码中，在业务代码中加载 externals:[&apos;lodash&apos;], output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), // 文件打包后的文件名字 filename: &apos;library.js&apos;, //可以使用src引入变为全局变量 library:&apos;library&apos;, //以上library挂载的地方（比如this window等） libraryTarget: &quot;umd&quot; &#125;&#125;;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack4+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo搭建个人博客]]></title>
    <url>%2F2019%2F01%2F24%2Fposts%2F</url>
    <content type="text"><![CDATA[所谓博客，都是孤芳自赏 现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地+localhost:4000可以看到博客已经搭建成功） 站内搜索配置首先安装hexo-generator-searchdb插件 npm install hexo-generator-searchdb –save 编辑博客根目录下的博客本地目录/_config.yml站点配置文件，新增以下内容到任意位置，search顶格放否则可能没效果： search: path: search.xml field: post format: html limit: 10000 编辑博客本地目录/themes/next/_config.yml 主题配置文件，启用本地搜索功能,将local_search:下面的enable:的值，改成true可以输入以下命令，先清理缓存，然后本地部署调试 hexo cleanhexo s 搜索无效、一直loading的问题按F12可以查看请求命令的状态，状态码200表示请求成功。但是搜索动画还是一直在转。1.文章中包含特殊字符，文件编码时出错 部署githubMyBlog文件夹安装 npm install –save hexo-deployer-git 找到 _config.yml文件修改一下文件deploy:type: gitrepo: https://github.com/Zhanghuaxiao/Zhanghuaxiao.github.io.gitbranch: master 最后运行hexo clean(清除) hexo g(生成) hexo d(部署)点击查看效果: https://zhanghuaxiao.github.io/ 使用nexT主题 安装 git clone 修改_config.yml文件中 theme:next 运行 hexo clean hexo s hexo和nexT中文网 hexo中文网 nexT中文官网 nexT主题参考文章 对nexT主题设置 seo优化 Hexo博客Next主题站内搜索模块相关，解决搜索无效、一直loading的问题]]></content>
      <categories>
        <category>hexo的使用</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
        <tag>搭建自己博客</tag>
        <tag>解决next主题搜索loadding问题</tag>
      </tags>
  </entry>
</search>
