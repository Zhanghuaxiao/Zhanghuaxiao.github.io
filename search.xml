<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gulp和webpack区别]]></title>
    <url>%2F2019%2F01%2F29%2Fgulp%E5%92%8Cwebpack%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[我愿化身石桥，受五百年风吹，五百年日晒，五百年雨淋，只求她从桥上经过 原文地址 gulpgulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。 PS：简单说就一个Task Runner webpackwebpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。PS：webpack is a module bundle 相同功能gulp与webpack可以实现一些相同功能，如下（列举部分）： 功能 gulp webpack 文件合并与压缩（css） 使用gulp-minify-css模块 样式合并一般用到extract-text-webpack-plugin插件压缩则使用webpack.optimize.UglifyJsPlugin 文件合并与压缩（js） 使用gulp-uglify和gulp-concat两个模块 js合并在模块化开始就已经做,压缩则使用webpack.optimize.UglifyJsPlugin sass/less预编译 使用gulp-sass/gulp-less 模块 sass-loader/less-loader 进行预处理 启动server 使用gulp-webserver模块 使用webpack-dev-server模块 版本控制 使用gulp-rev和gulp-rev-collector两个模块 将生成文件加上hash值 module.exports = {plugins:[new ExtractTextPlugin(style.[hash].css”)} 两者区别 虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。 gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。 webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。 总结 gulp应该与grunt比较，而webpack应该与browserify（网上太多资料就这么说，这么说是没有错，不过单单这样一句话并不能让人清晰明了）。 gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。]]></content>
      <tags>
        <tag>gulp和webpack区别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js模块化编程弄懂CommonJS和AMD/CMD！]]></title>
    <url>%2F2019%2F01%2F28%2FCommonJs-AMD-CMD%2F</url>
    <content type="text"><![CDATA[为什么模块很重要？ 因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！ 原文链接 CommonJS 一开始大家都认为JS是辣鸡，没什么用，官方定义的API只能构建基于浏览器的应用程序，逗我呢，这太狭隘了吧(用了个高端词，嘎嘎)，CommonJS就按耐不住了，CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序： (1).服务器端JavaScript应用程序(2).命令行工具(3).图形界面应用程序(4).混合应用程序（如，Titanium或Adobe AIR） 2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。 node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。 var math = require(‘math’); 然后，就可以调用模块提供的方法： var math = require(‘math’); math.add(2,3); // 5 CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)} require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。 虽说Node遵循CommonJS的规范，但是相比也是做了一些取舍，填了一些新东西的。 不过，说了CommonJS也说了Node，那么我觉得也得先了解下NPM了。NPM作为Node的包管理器，不是为了帮助Node解决依赖包的安装问题嘛，那它肯定也要遵循CommonJS规范啦，它遵循包规范（还是理论）的。CommonJS WIKI讲了它的历史，还介绍了modules和packages等。 下面讲讲commonJS的原理以及简易实现： 原理浏览器不支持CommonJS原因，在于缺少四个Node.js环境变量 module exports require global只要能提供这4个变量，浏览器就能加载CommonJS模块下面一个简单示例 var module = { exports : {} }; (function(module,exports){ exports.multiply = function(n){return n*100} }(module,module.exports)) var f = module.exports.multiply; f(5) // 500 上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。 Browserify 的实现知道了原理，就能做出工具了。Browserify 是目前最常用的 CommonJS 格式转换的工具。 请看一个例子，main.js 模块加载 foo.js 模块。 12345678// foo.jsmodule.exports = function(x) &#123;console.log(x);&#125;;// main.jsvar foo = require(&quot;./foo&quot;);foo(&quot;Hi&quot;); 使用下面的命令，就能将main.js转为浏览器可用的格式。 $ browserify main.js &gt; compiled.jsBrowserify到底做了什么？安装一下browser-unpack，就能看清楚了。$ npm install browser-unpack -g然后，将前面生成的compile.js解包。 $ browser-unpack &lt; compiled.js 12345678910111213[ &#123; &quot;id&quot;:1, &quot;source&quot;:&quot;module.exports = function(x) &#123;\n console.log(x);\n&#125;;&quot;, &quot;deps&quot;:&#123;&#125; &#125;, &#123; &quot;id&quot;:2, &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;, &quot;deps&quot;:&#123;&quot;./foo&quot;:1&#125;, &quot;entry&quot;:true &#125;] 可以看到，browerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。 因为main.js加载了foo.js,所以deps属性就指定./foo对应1号模块。执行时候，浏览器遇到require(./foo)语句，就自动执行1好模块的source属性，并将执行后module.exports属性值输出 Tiny Browser Require虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。我根据 mocha 的内部实现，做了一个纯浏览器的 CommonJS 模块加载器 tiny-browser-require 。完全不需要命令行，直接放进浏览器即可，所有代码只有30多行。 它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。123456789101112131415161718192021222324252627282930313233343536373839404142 function require(p)&#123; var path = require.resolve(p); //node.js语法加载当前模块目录下的绝对路径 var mod = require.modules[path]; if (!mod) throw new Error(&apos;failed to require &quot;&apos; + p + &apos;&quot;&apos;); if (!mod.exports) &#123; mod.exports = &#123;&#125;; mod.call(mod.exports, mod, mod.exports, require.relative(path)); &#125; return mod.exports;&#125;require.modules = &#123;&#125;;require.resolve = function (path)&#123; var orig = path; var reg = path + &apos;.js&apos;; var index = path + &apos;/index.js&apos;; return require.modules[reg] &amp;&amp; reg || require.modules[index] &amp;&amp; index || orig;&#125;;require.register = function (path, fn)&#123; require.modules[path] = fn;&#125;;require.relative = function (parent) &#123; return function(p)&#123; if (&apos;.&apos; != p.charAt(0)) return require(p); var path = parent.split(&apos;/&apos;); var segs = p.split(&apos;/&apos;); path.pop(); for (var i = 0; i &lt; segs.length; i++) &#123; var seg = segs[i]; if (&apos;..&apos; == seg) path.pop(); else if (&apos;.&apos; != seg) path.push(seg); &#125; return require(path.join(&apos;/&apos;)); &#125;;&#125;;使用的时候，先将上面的代码放入页面。然后，将模块放在如下的立即执行函数里面，就可以调用了。 &lt;script src=&quot;require.js&quot; /&gt; &lt;script&gt; require.register(&quot;moduleId&quot;, function(module, exports, require){ // Module code goes here }); var result = require(&quot;moduleId&quot;); &lt;/script&gt; 还是以前面的 main.js 加载 foo.js 为例。 require.register(&quot;./foo.js&quot;, function(module, exports, require){ module.exports = function(x) { console.log(x); }; }); var foo = require(&quot;./foo.js&quot;); foo(&quot;Hi&quot;); 注意，这个库只模拟了 require 、module 、exports 三个变量，如果模块还用到了 global 或者其他 Node 专有变量（比如 process），就通过立即执行函数提供即可。 AMD基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上面的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？ var math = require(‘math’);math.add(2, 3); 第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。您会注意到 require 是同步的。 这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。 因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。 CommonJS是主要为了JS在后端的表现制定的，他是不适合前端的，AMD(异步模块定义)出现了，它就主要为前端JS的表现制定规范。 AMD是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。 AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数： require([module], callback); 第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：123require([&apos;math&apos;], function (math) &#123; math.add(2, 3); &#125;); math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。目前，主要有两个Javascript库实现了AMD规范：require.js和curl.js。 RequireJS就是实现了AMD规范的呢。详细概括：下面以RequireJS为例说明AMD规范 为什么要用require.js？最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。123456&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;这段代码依次加载多个js文件。这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 require.js的诞生，就是为了解决这两个问题： (1) 实现js文件的异步加载，避免网页失去响应；(2) 管理模块之间的依赖性，便于代码的编写和维护。 require.js的加载使用require.js的第一步，是先去官方网站下载最新版本。下载后，假定把它放在js子目录下面，就可以加载了。 &lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt; 有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样： &lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： &lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 主模块的写法上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。下面就来看，怎么写main.js。如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。 // main.js alert(“加载成功！”); 但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。 // main.js require([‘moduleA’, ‘moduleB’, ‘moduleC’], function (moduleA, moduleB, moduleC){ // some code here }); require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。 require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 下面，我们看一个实际的例子。假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写： require([‘jquery’, ‘underscore’, ‘backbone’], function ($, _, Backbone){ // some code here }); require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。 模块的加载上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。 使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 require.config({ paths: { “jquery”: “jquery.min”, “underscore”: “underscore.min”, “backbone”: “backbone.min” } }); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。 require.config({ paths: { “jquery”: “lib/jquery.min”, “underscore”: “lib/underscore.min”, “backbone”: “lib/backbone.min” } }); 另一种则是直接改变基目录（baseUrl）。 require.config({ baseUrl: “js/lib”, paths: { “jquery”: “jquery.min”, “underscore”: “underscore.min”, “backbone”: “backbone.min” } }); 如果某个模块在另一台主机上，也可以直接指定它的网址，比如： require.config({ paths: { “jquery”: “https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot; } }); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 AMD模块的写法require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写： // math.js define(function (){ var add = function (x,y){ return x+y; }; return { add: add }; }); 加载方法如下： // main.js require([‘math’], function (math){ alert(math.add(1,1)); }); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 define([‘myLib’], function(myLib){ function foo(){ myLib.doSomething(); } return { foo : foo }; }); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 加载非规范的模块理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？ 回答是可以的。 这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。 require.config({ shim: { ‘underscore’:{ exports: ‘_’ }, ‘backbone’: { deps: [‘underscore’, ‘jquery’], exports: ‘Backbone’ } } }); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。 比如，jQuery的插件可以这样定义： shim: { ‘jquery.scroll’: { deps: [‘jquery’], exports: ‘jQuery.fn.scroll’ } } require.js插件require.js还提供一系列插件，实现一些特定的功能。 domready插件，可以让回调函数在页面DOM结构加载完成后再运行。 require([‘domready!’], function (doc){ // called once the DOM is ready }); text和image插件，则是允许require.js加载文本和图片文件。 define([ ‘text!review.txt’, ‘image!cat.jpg’ ], function(review,cat){ console.log(review); document.body.appendChild(cat); } ); 类似的插件还有json和mdown，用于加载json文件和markdown文件。（完） 另一个人的概括(有点简单)： AMD就只有一个接口：define(id?,dependencies?,factory); 它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样： define([‘dep1’,’dep2’],function(dep1,dep2){…}); 要是没什么依赖，就定义简单的模块，下面这样就可以啦： define(function(){ var exports = {}; exports.method = function(){...}; return exports; }); 咦，这里有define，把东西包装起来啦，那Node实现中怎么没看到有define关键字呢，它也要把东西包装起来呀，其实吧，只是Node隐式包装了而已….. 这有AMD的WIKI中文版，讲了很多蛮详细的东西，用到的时候可以查看：AMD的WIKI中文版 CMD大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版，应有尽有：seajs官方doc define(function(require,exports,module){…}); 用过seajs吧，这个不陌生吧，对吧。 前面说AMD，说RequireJS实现了AMD，CMD看起来与AMD好像呀，那RequireJS与SeaJS像不像呢？ 虽然CMD与AMD蛮像的，但区别还是挺明显的，官方非官方都有阐述和理解，我觉得吧，说的都挺好： 官方阐述SeaJS与RequireJS异同 SeaJS与RequireJS的最大异同（这个说的也挺好)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>CommonJS/AMD/CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用 JavaScript 和 Emoji 做地址栏动画]]></title>
    <url>%2F2019%2F01%2F27%2FEmojis-url%2F</url>
    <content type="text"><![CDATA[同样是9年义务教育，你为何这么优秀 译者：Wpeach 原文作者：Matthew Rayfield 原文地址：Animating URLs with Javascript and Emojis 你可以在地址栏使用 emoji（和其它图形 unicode 字符），这看着很棒，但是好像没人这么做，为什么呢？也许 emoji 对于正常的网络平台来说太过异国情调了？或许是他们因为害怕不利于SEO？不管什么原因，维恩图中的合理性观点“没人这么做，但这是可能的”是让我兴奋的点。所以我决定花费一些时间研究在地址栏中图形字符的可能性，特别是通过 JavaScript 给这些字符加上动画。循环动画首先，确保你页面的 JavaScript 代码是 UTF-8 编码，否则无法在你的代码中显示 emoji，这可以通过设置 HTTP 头部或页面的 META 标签来实现。你很可能不用担心这个，但你可以在这里找到更多信息：Unicode in Javascript by Flavio。为了达到我们想要的效果，让 emoji 像小仙女一样在地址栏里偏偏起舞，我们需要一个循环，实际上，我们所需要的只是一个循环，我们启动这个循环，它不断循环，我们的目的就达到了。这是我们的第一个循环动画，一个旋转的emoji 月亮。我猜当他们添加这个 emoji 序列时，也有这个想法吧？ var f = [&apos;🌑&apos;, &apos;🌒&apos;, &apos;🌓&apos;, &apos;🌔&apos;, &apos;🌝&apos;, &apos;🌖&apos;, &apos;🌗&apos;, &apos;🌘&apos;]; function loop() { location.hash = f[Math.floor((Date.now()/100)%f.length)]; setTimeout(loop, 50); } loop(); 复制代码运行代码，你可以在地址栏看到此循环的结果。如果你不喜欢旋转的月亮，你可以选择任何你喜欢的 emoji 来替换这个数组，比如一个时钟： var f = [‘🕐’,’🕑’,’🕒’,’🕓’,’🕔’,’🕕’,’🕖’,’🕗’,’🕘’,’🕙’,’🕚’,’🕛’];复制代码这是一个非常简单的例子，真的非常简单，所以我们来升级一下循环，让它显示一串 emoji ! 这次我们使用 emoji 的skin tone modifiers肤色调节属性来制作一些变色宝宝： var e = [&apos;🏻&apos;, &apos;🏼&apos;, &apos;🏽&apos;, &apos;🏾&apos;, &apos;🏿&apos;]; function loop() { var s = &apos;&apos;, i, m; for (i = 0; i &lt; 10; i ++) { m = Math.floor(e.length * ((Math.sin((Date.now()/100) + i)+1)/2)); s += &apos;👶&apos; + e[m]; } location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我们可以使用时间和位置控制的正弦波来选择我们想要的颜色，这给了我们一个很好的颜色变幻效果！比如我们再来一次月亮旋转，使它展开，制作一个类似于加载条的动画？好的，开始实现： var f = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;, &apos;🌔&apos;, &apos;🌓&apos;, &apos;🌒&apos;], d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], m = 0; function loop() { var s = &apos;&apos;, x = 0; if (!m) { while (d[x] == 4) { x ++; } if (x &gt;= d.length) m = 1; else { d[x] ++; } } else { while (d[x] == 0) { x ++; } if (x &gt;= d.length) m = 0; else { d[x] ++; if (d[x] == 8) d[x] = 0; } } d.forEach(function (n) { s += f[n]; }); location.hash = s; setTimeout(loop, 50); } loop(); 复制代码探索其它字符不止是 emoji 给我们提供了一种在地址栏显示图形的方法，我们的目标中也有一些 unicode 字符。特别有趣的是 框线字符: 它们中很多更适合二维输出，但它们在一维输出也很棒，例如，我们可以创建一个多个高度变化的块字符串，并构造一个漂亮的小波浪动画： function loop() { var i, n, s = &apos;&apos;; for (i = 0; i &lt; 10; i++) { n = Math.floor(Math.sin((Date.now()/200) + (i/2)) * 4) + 4; s += String.fromCharCode(0x2581 + n); } window.location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我非常喜欢它的效果，我把它永久放在了 wavyurl.com 上。使用可变宽度字符，我们甚至在水平方向上摆动，创建类似于进度条的东西： function loop() { var s = &apos;&apos;, p; p = Math.floor(((Math.sin(Date.now()/300)+1)/2) * 100); while (p &gt;= 8) { s += &apos;█&apos;; p -= 8; } s += [&apos;⠀&apos;,&apos;▏&apos;,&apos;▎&apos;,&apos;▍&apos;,&apos;▌&apos;,&apos;▋&apos;,&apos;▊&apos;,&apos;▉&apos;][p]; location.hash = s; setTimeout(loop, 50); } 复制代码进度条？这看起来，还是有用的，这让我想到了……在地址栏显示视频进度为了增加我们小实验的可能性，我提出了在地址栏中显示网络视频进度的想法。我只需附加一个函数，将我们的进度字符串定义在视频的timeupdate事件中，瞧！地址栏中的视频进度条包含时间和持续时间！ var video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, l = 15, p = Math.floor(video.currentTime / video.duration * (l-1)), i; for (i = 0; i &lt; l; i ++) { if (i == p) s +=&apos;◯&apos;; else if (i &lt; p) s += &apos;─&apos;; else s += &apos;┄&apos;; } location.hash = &apos;╭&apos;+s+&apos;╮&apos;+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码我比较喜欢这个线条和圆组成的进度条，如果你喜欢别的 emoji 比如月亮，我也能让你满意： var e = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;], video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, c = 0, l = 10, p = Math.floor(video.currentTime / video.duration * ((l*5)-1)), i; while (p &gt;= 5) { s += e[4]; c ++; p -= 5; } s += e[p]; c ++; while (c &lt; l) { s += e[0]; c ++; } location.hash = s+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码好的，将此进度条称为“有用”的延伸。 只瞄一眼，我也可以看到在视频分享 URL 中的进度。 与YouTube一样，你可以选择在特定时间创建指向视频的链接，添加视觉指示是不是很酷？嗯？也许我还没有提出一些更有用的“技术”实现，我会继续思考这个问题。 嘿，也许你可以尝试一些东西？最后你可能想知道为什么我使用location.hash =，而不是新且酷的HTML5 History API。 有两个原因：第一个问题是 History API有一个特点：它实际上更改了整个 URL 路径，而不仅仅是 hash。 因此，如果我使用 History API 并将页面更改为/🌑🌘🌗🌖🌕，它看起来会比添加 ＃ 更好。 但这也意味着我的 Web 服务器必须能够响应/🌑🌘🌗🌖🌕，否则如果用户刷新或以其他方式导航到修改后的 URL 将会失败。 这是可行的，但比使用location.hash =更复杂，需要我修改服务器配置。第二个问题有些出乎意料。 实际上，在我测试的3个浏览器中，有2个历史API被限制的。 如果我以极快的速度将我的波形网址推送到地址栏，我最终会在 Chrome 中收到以下错误： Throttling history state changes to prevent the browser from hanging. Safari 给我们提供了更详细的信息： SecurityError: Attempt to use history.pushState() more than 100 times per 30.000000 seconds 现在，如果让我保持在这个限制下也行，但是每秒3帧只是不会影响我目前的动画效果。好孩子 Firefox 似乎并不在乎我推送新历史的次数和速度，这真是想得太周到了。但是，两个主要的浏览器受到影响，加上需要web服务器配置来修复第一个问题，使我更愿意忍受 URL 中的 #。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>用JavaScript和Emoji 做地址栏动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.29.0基本用法]]></title>
    <url>%2F2019%2F01%2F25%2Fwebpack4-29-0%2F</url>
    <content type="text"><![CDATA[不积跬步无以至千里，不积小流无以成江海 从2009到2019社会在不断进步 技术也在不断进步 我们当然也不能落后 准备工作 全局安装webpack和webpack-cli sudo npm install webpack -gsudo npm install webpack-cli -g 文件夹下局部安装 npm init -ysudo npm install webpack –save-devsudo npm install webpack-cli –save-dev 实现对一个js文件打包1234567891011//webpack.config.jsconst path = require(&apos;path&apos;)module.exports = &#123; mode:&apos;development&apos;, entry:&apos;./app.js&apos;, output:&#123; filename:&apos;[name].bundle.js&apos;, path:path.join(__dirname,&apos;./dist&apos;), &#125;&#125;这样就能在dist目录下出现一个app.bundle.js文件啦！ 实现多个js文件打包12345678910111213141516171819//webpack.config.jsconst path = require(&apos;path&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; index: &apos;./src/index.js&apos;, test: &apos;./src/test.js&apos;, test1: &apos;./src/test1.js&apos;, &#125;, output: &#123; path: path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, pubicPath: &apos;http://cdn.con&apos; //请求时会自己加协议（location.protocol=&apos;http&apos;）和端口号(host=&apos;cdn.con&apos;) &#125;， plugins: [ new CleanWebpackPlugin ([&apos;./dist/js&apos;]) //清除之前打包的文件 ]&#125; 使用模版实现每个js对应自己的html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//webpack.config.jsconst path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //模版loaderconst CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; entry:&#123; index:&apos;./src/index.js&apos;, test:&apos;./src/test.js&apos;, test1:&apos;./src/test1.js&apos;, &#125;, output:&#123; path:path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, publicPath:&quot;http://cdn.com&quot; &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: &apos;this a index.html&apos;, //每个html 的title template:&apos;hello.html&apos;, filename:&apos;index.html&apos;, excludeChunks:[&apos;test&apos;,&apos;test1&apos;] //排除名为test.js,test1.js打包的js文件 &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test.html&apos;, excludeChunks:[&apos;index&apos;,&apos;test1&apos;] &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test1.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test1.html&apos;, excludeChunks:[&apos;test&apos;,&apos;index&apos;] &#125;), new CleanWebpackPlugin([&apos;./dist/js&apos;]) ]&#125;//hello.html 模版内容&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.test1.entry.substr (htmlWebpackPlugin.files.publicPath.length)].source() %&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;% for(let k in htmlWebpackPlugin.files.chunks) &#123;%&gt; &lt;% if(k != &apos;index&apos;) &#123;%&gt; &lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks[k].entry %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125;%&gt; &lt;% &#125; %&gt;&lt;/body&gt; 使用file-loader|css-loader|style-loader|postcss-loader1234567891011121314151617181920212223242526272829303132333435//webpack.config.jsmodule.exports = &#123;mode: &apos;development&apos;,entry: &apos;./app.js&apos;,output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.join(__dirname, &apos;./dist/js1&apos;),&#125;,plugins: [ new CleanWebpackPlugin([&apos;./dist/js1&apos;]), require(&apos;autoprefixer&apos;)],module: &#123; rules: [ &#123; test: /\.(le|c)ss$/, test: /\.(png|jpg|gif)$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125;, &#123; loader: &apos;file-loader&apos;&#125;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&quot;autoprefixer&quot;) /*在这里添加*/, ], &#125; &#125; ] &#125; ] &#125;,&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack4+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo搭建个人博客]]></title>
    <url>%2F2019%2F01%2F24%2Fposts%2F</url>
    <content type="text"><![CDATA[所谓博客，都是孤芳自赏 现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地+localhost:4000可以看到博客已经搭建成功） 部署github 在MyBlog下安装 npm install –save hexo-deployer-git 找到_config.yml文件修改一下文件 deploy:type: gitrepo: https://github.com/Zhanghuaxiao/Zhanghuaxiao.github.io.gitbranch: master 最后运行 hexo clean(清除) hexo g(生成) hexo d(部署) 点击查看效果: https://zhanghuaxiao.github.io/ 使用nexT主题 安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_config.yml文件中 theme:next 运行hexo clean hexo s hexo和nexT中文网 hexo中文网 https://hexo.io/zh-cn/docs/helpersnexT中文官网 http://theme-next.iissnan.com/getting-started.html nexT主题参考文章 对nexT主题设置:https://segmentfault.com/a/1190000009544924#articleHeader2seo优化:https://www.jianshu.com/p/86557c34b671]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
        <tag>搭建自己博客</tag>
      </tags>
  </entry>
</search>
