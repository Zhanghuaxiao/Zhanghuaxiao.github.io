<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[用 JavaScript 和 Emoji 做地址栏动画]]></title>
    <url>%2F2019%2F01%2F27%2FEmojis-url%2F</url>
    <content type="text"><![CDATA[同样是9年义务教育，你为何这么优秀 译者：Wpeach 原文作者：Matthew Rayfield 原文地址：Animating URLs with Javascript and Emojis 你可以在地址栏使用 emoji（和其它图形 unicode 字符），这看着很棒，但是好像没人这么做，为什么呢？也许 emoji 对于正常的网络平台来说太过异国情调了？或许是他们因为害怕不利于SEO？不管什么原因，维恩图中的合理性观点“没人这么做，但这是可能的”是让我兴奋的点。所以我决定花费一些时间研究在地址栏中图形字符的可能性，特别是通过 JavaScript 给这些字符加上动画。循环动画首先，确保你页面的 JavaScript 代码是 UTF-8 编码，否则无法在你的代码中显示 emoji，这可以通过设置 HTTP 头部或页面的 META 标签来实现。你很可能不用担心这个，但你可以在这里找到更多信息：Unicode in Javascript by Flavio。为了达到我们想要的效果，让 emoji 像小仙女一样在地址栏里偏偏起舞，我们需要一个循环，实际上，我们所需要的只是一个循环，我们启动这个循环，它不断循环，我们的目的就达到了。这是我们的第一个循环动画，一个旋转的emoji 月亮。我猜当他们添加这个 emoji 序列时，也有这个想法吧？ var f = [&apos;🌑&apos;, &apos;🌒&apos;, &apos;🌓&apos;, &apos;🌔&apos;, &apos;🌝&apos;, &apos;🌖&apos;, &apos;🌗&apos;, &apos;🌘&apos;]; function loop() { location.hash = f[Math.floor((Date.now()/100)%f.length)]; setTimeout(loop, 50); } loop(); 复制代码运行代码，你可以在地址栏看到此循环的结果。如果你不喜欢旋转的月亮，你可以选择任何你喜欢的 emoji 来替换这个数组，比如一个时钟： var f = [‘🕐’,’🕑’,’🕒’,’🕓’,’🕔’,’🕕’,’🕖’,’🕗’,’🕘’,’🕙’,’🕚’,’🕛’];复制代码这是一个非常简单的例子，真的非常简单，所以我们来升级一下循环，让它显示一串 emoji ! 这次我们使用 emoji 的skin tone modifiers肤色调节属性来制作一些变色宝宝： var e = [&apos;🏻&apos;, &apos;🏼&apos;, &apos;🏽&apos;, &apos;🏾&apos;, &apos;🏿&apos;]; function loop() { var s = &apos;&apos;, i, m; for (i = 0; i &lt; 10; i ++) { m = Math.floor(e.length * ((Math.sin((Date.now()/100) + i)+1)/2)); s += &apos;👶&apos; + e[m]; } location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我们可以使用时间和位置控制的正弦波来选择我们想要的颜色，这给了我们一个很好的颜色变幻效果！比如我们再来一次月亮旋转，使它展开，制作一个类似于加载条的动画？好的，开始实现： var f = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;, &apos;🌔&apos;, &apos;🌓&apos;, &apos;🌒&apos;], d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], m = 0; function loop() { var s = &apos;&apos;, x = 0; if (!m) { while (d[x] == 4) { x ++; } if (x &gt;= d.length) m = 1; else { d[x] ++; } } else { while (d[x] == 0) { x ++; } if (x &gt;= d.length) m = 0; else { d[x] ++; if (d[x] == 8) d[x] = 0; } } d.forEach(function (n) { s += f[n]; }); location.hash = s; setTimeout(loop, 50); } loop(); 复制代码探索其它字符不止是 emoji 给我们提供了一种在地址栏显示图形的方法，我们的目标中也有一些 unicode 字符。特别有趣的是 框线字符: 它们中很多更适合二维输出，但它们在一维输出也很棒，例如，我们可以创建一个多个高度变化的块字符串，并构造一个漂亮的小波浪动画： function loop() { var i, n, s = &apos;&apos;; for (i = 0; i &lt; 10; i++) { n = Math.floor(Math.sin((Date.now()/200) + (i/2)) * 4) + 4; s += String.fromCharCode(0x2581 + n); } window.location.hash = s; setTimeout(loop, 50); } loop(); 复制代码我非常喜欢它的效果，我把它永久放在了 wavyurl.com 上。使用可变宽度字符，我们甚至在水平方向上摆动，创建类似于进度条的东西： function loop() { var s = &apos;&apos;, p; p = Math.floor(((Math.sin(Date.now()/300)+1)/2) * 100); while (p &gt;= 8) { s += &apos;█&apos;; p -= 8; } s += [&apos;⠀&apos;,&apos;▏&apos;,&apos;▎&apos;,&apos;▍&apos;,&apos;▌&apos;,&apos;▋&apos;,&apos;▊&apos;,&apos;▉&apos;][p]; location.hash = s; setTimeout(loop, 50); } 复制代码进度条？这看起来，还是有用的，这让我想到了……在地址栏显示视频进度为了增加我们小实验的可能性，我提出了在地址栏中显示网络视频进度的想法。我只需附加一个函数，将我们的进度字符串定义在视频的timeupdate事件中，瞧！地址栏中的视频进度条包含时间和持续时间！ var video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, l = 15, p = Math.floor(video.currentTime / video.duration * (l-1)), i; for (i = 0; i &lt; l; i ++) { if (i == p) s +=&apos;◯&apos;; else if (i &lt; p) s += &apos;─&apos;; else s += &apos;┄&apos;; } location.hash = &apos;╭&apos;+s+&apos;╮&apos;+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码我比较喜欢这个线条和圆组成的进度条，如果你喜欢别的 emoji 比如月亮，我也能让你满意： var e = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;], video; function formatTime(seconds) { var minutes = Math.floor(seconds/60), seconds = Math.floor(seconds - (minutes*60)); return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2); } function renderProgressBar() { var s = &apos;&apos;, c = 0, l = 10, p = Math.floor(video.currentTime / video.duration * ((l*5)-1)), i; while (p &gt;= 5) { s += e[4]; c ++; p -= 5; } s += e[p]; c ++; while (c &lt; l) { s += e[0]; c ++; } location.hash = s+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration); } video = document.getElementById(&apos;video&apos;); video.addEventListener(&apos;timeupdate&apos;, renderProgressBar); 复制代码好的，将此进度条称为“有用”的延伸。 只瞄一眼，我也可以看到在视频分享 URL 中的进度。 与YouTube一样，你可以选择在特定时间创建指向视频的链接，添加视觉指示是不是很酷？嗯？也许我还没有提出一些更有用的“技术”实现，我会继续思考这个问题。 嘿，也许你可以尝试一些东西？最后你可能想知道为什么我使用location.hash =，而不是新且酷的HTML5 History API。 有两个原因：第一个问题是 History API有一个特点：它实际上更改了整个 URL 路径，而不仅仅是 hash。 因此，如果我使用 History API 并将页面更改为/🌑🌘🌗🌖🌕，它看起来会比添加 ＃ 更好。 但这也意味着我的 Web 服务器必须能够响应/🌑🌘🌗🌖🌕，否则如果用户刷新或以其他方式导航到修改后的 URL 将会失败。 这是可行的，但比使用location.hash =更复杂，需要我修改服务器配置。第二个问题有些出乎意料。 实际上，在我测试的3个浏览器中，有2个历史API被限制的。 如果我以极快的速度将我的波形网址推送到地址栏，我最终会在 Chrome 中收到以下错误： Throttling history state changes to prevent the browser from hanging. Safari 给我们提供了更详细的信息： SecurityError: Attempt to use history.pushState() more than 100 times per 30.000000 seconds 现在，如果让我保持在这个限制下也行，但是每秒3帧只是不会影响我目前的动画效果。好孩子 Firefox 似乎并不在乎我推送新历史的次数和速度，这真是想得太周到了。但是，两个主要的浏览器受到影响，加上需要web服务器配置来修复第一个问题，使我更愿意忍受 URL 中的 #。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>用JavaScript和Emoji 做地址栏动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4.29.0基本用法]]></title>
    <url>%2F2019%2F01%2F25%2Fwebpack4-29-0%2F</url>
    <content type="text"><![CDATA[不积跬步无以至千里，不积小流无以成江海 从2009到2019社会在不断进步 技术也在不断进步 我们当然也不能落后 准备工作 全局安装webpack和webpack-cli sudo npm install webpack -gsudo npm install webpack-cli -g 文件夹下局部安装 npm init -ysudo npm install webpack –save-devsudo npm install webpack-cli –save-dev 实现对一个js文件打包1234567891011//webpack.config.jsconst path = require(&apos;path&apos;)module.exports = &#123; mode:&apos;development&apos;, entry:&apos;./app.js&apos;, output:&#123; filename:&apos;[name].bundle.js&apos;, path:path.join(__dirname,&apos;./dist&apos;), &#125;&#125;这样就能在dist目录下出现一个app.bundle.js文件啦！ 实现多个js文件打包12345678910111213141516171819//webpack.config.jsconst path = require(&apos;path&apos;)const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; mode: &apos;development&apos;, entry: &#123; index: &apos;./src/index.js&apos;, test: &apos;./src/test.js&apos;, test1: &apos;./src/test1.js&apos;, &#125;, output: &#123; path: path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, pubicPath: &apos;http://cdn.con&apos; //请求时会自己加协议（location.protocol=&apos;http&apos;）和端口号(host=&apos;cdn.con&apos;) &#125;， plugins: [ new CleanWebpackPlugin ([&apos;./dist/js&apos;]) //清除之前打包的文件 ]&#125; 使用模版实现每个js对应自己的html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//webpack.config.jsconst path = require(&apos;path&apos;)const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //模版loaderconst CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)module.exports = &#123; entry:&#123; index:&apos;./src/index.js&apos;, test:&apos;./src/test.js&apos;, test1:&apos;./src/test1.js&apos;, &#125;, output:&#123; path:path.join(__dirname,&apos;./dist/js&apos;), filename:&apos;[name]-[hash].js&apos;, publicPath:&quot;http://cdn.com&quot; &#125;, plugins:[ new HtmlWebpackPlugin(&#123; title: &apos;this a index.html&apos;, //每个html 的title template:&apos;hello.html&apos;, filename:&apos;index.html&apos;, excludeChunks:[&apos;test&apos;,&apos;test1&apos;] //排除名为test.js,test1.js打包的js文件 &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test.html&apos;, excludeChunks:[&apos;index&apos;,&apos;test1&apos;] &#125;), new HtmlWebpackPlugin(&#123; title:&apos;this a test1.js&apos;, template:&apos;hello.html&apos;, filename:&apos;test1.html&apos;, excludeChunks:[&apos;test&apos;,&apos;index&apos;] &#125;), new CleanWebpackPlugin([&apos;./dist/js&apos;]) ]&#125;//hello.html 模版内容&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;&lt;script type=&quot;text/javascript&quot;&gt; &lt;%= compilation.assets[htmlWebpackPlugin.files.chunks.test1.entry.substr (htmlWebpackPlugin.files.publicPath.length)].source() %&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;% for(let k in htmlWebpackPlugin.files.chunks) &#123;%&gt; &lt;% if(k != &apos;index&apos;) &#123;%&gt; &lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks[k].entry %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125;%&gt; &lt;% &#125; %&gt;&lt;/body&gt; 使用file-loader|css-loader|style-loader|postcss-loader1234567891011121314151617181920212223242526272829303132333435//webpack.config.jsmodule.exports = &#123;mode: &apos;development&apos;,entry: &apos;./app.js&apos;,output: &#123; filename: &apos;[name].bundle.js&apos;, path: path.join(__dirname, &apos;./dist/js1&apos;),&#125;,plugins: [ new CleanWebpackPlugin([&apos;./dist/js1&apos;]), require(&apos;autoprefixer&apos;)],module: &#123; rules: [ &#123; test: /\.(le|c)ss$/, test: /\.(png|jpg|gif)$/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125;, &#123; loader: &apos;file-loader&apos;&#125;, &#123; loader: &quot;postcss-loader&quot;, options: &#123; plugins: [ require(&quot;autoprefixer&quot;) /*在这里添加*/, ], &#125; &#125; ] &#125; ] &#125;,&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>webpack4+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo搭建个人博客]]></title>
    <url>%2F2019%2F01%2F24%2Fposts%2F</url>
    <content type="text"><![CDATA[所谓博客，都是孤芳自赏 现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。 准备工作 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo 本地搭建hexo静态博客 新建一个文件夹，如MyBlog 进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙） 生成完模板，运行npm install（目前貌似不用运行这一步） 最后运行：hexo server （运行程序，访问本地+localhost:4000可以看到博客已经搭建成功） 部署github 在MyBlog下安装 npm install –save hexo-deployer-git 找到_config.yml文件修改一下文件 deploy:type: gitrepo: https://github.com/Zhanghuaxiao/Zhanghuaxiao.github.io.gitbranch: master 最后运行 hexo clean(清除) hexo g(生成) hexo d(部署) 点击查看效果: https://zhanghuaxiao.github.io/ 使用nexT主题 安装 git clone https://github.com/iissnan/hexo-theme-next themes/next 修改_config.yml文件中 theme:next 运行hexo clean hexo s hexo和nexT中文网 hexo中文网 https://hexo.io/zh-cn/docs/helpersnexT中文官网 http://theme-next.iissnan.com/getting-started.html nexT主题参考文章 对nexT主题设置:https://segmentfault.com/a/1190000009544924#articleHeader2seo优化:https://www.jianshu.com/p/86557c34b671]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nexT</tag>
        <tag>搭建自己博客</tag>
      </tags>
  </entry>
</search>
