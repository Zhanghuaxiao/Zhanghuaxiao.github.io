<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Honey</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhanghuaxiao.github.io/"/>
  <updated>2019-02-14T15:19:57.235Z</updated>
  <id>https://zhanghuaxiao.github.io/</id>
  
  <author>
    <name>Honey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>图片懒加载</title>
    <link href="https://zhanghuaxiao.github.io/2019/02/14/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>https://zhanghuaxiao.github.io/2019/02/14/图片懒加载/</id>
    <published>2019-02-14T11:22:21.000Z</published>
    <updated>2019-02-14T15:19:57.235Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>LazyLoad </p></blockquote><p><img src="/img/lazyload.gif"><br><a id="more"></a></p><h1 id="懒加载的意义"><a href="#懒加载的意义" class="headerlink" title="懒加载的意义"></a>懒加载的意义</h1><p>这里‘懒’的意思可以理解为延迟，如淘宝、京东这些电商平台有大量的图片，如果上来就加载服务器表示压力山大，所以就想出了懒加载这种克敌之法，用户滚动到的区域才发送请求加载内容</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>将页面中的img标签src指向一张小照片或者为空都可以，然后写一个自定义属性比如（data-src）指向正确的图片，其实就是用正确的照片替换src里面的照片</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>在写代码前，需要了解各种高度。先看这篇文章<a href="https://zhanghuaxiao.github.io/2019/02/14/js获取事件坐标位置/">js坐标位置</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;style&gt;</span></span><br><span class="line"><span class="regexp">        img &#123;</span></span><br><span class="line"><span class="regexp">            display: block;</span></span><br><span class="line"><span class="regexp">            margin-bottom: 50px;</span></span><br><span class="line"><span class="regexp">            width: 400px;</span></span><br><span class="line"><span class="regexp">            height: 400px;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>style&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="" data-src="http:/</span><span class="regexp">/ww4.sinaimg.cn/</span>large/<span class="number">006</span>y8mN6gw1fa5obmqrmvj305k05k3yh.jpg<span class="string">" alt="</span><span class="string">"&gt;</span></span><br><span class="line"><span class="string">    &lt;img src="</span><span class="string">" data-src="</span>http:<span class="comment">//ww1.sinaimg.cn/large/006y8mN6gw1fa7kaed2hpj30sg0l9q54.jpg" alt=""&gt;</span></span><br><span class="line">    &lt;img src=<span class="string">""</span> data-src=<span class="string">"loadding.gif"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">""</span> data-src=<span class="string">"http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg"</span> alt=<span class="string">""</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;LazyLoad &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/lazyload.gif&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="图片懒加载" scheme="https://zhanghuaxiao.github.io/tags/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>js获取事件坐标位置</title>
    <link href="https://zhanghuaxiao.github.io/2019/02/14/js%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%9D%90%E6%A0%87%E4%BD%8D%E7%BD%AE/"/>
    <id>https://zhanghuaxiao.github.io/2019/02/14/js获取事件坐标位置/</id>
    <published>2019-02-14T09:21:15.000Z</published>
    <updated>2019-02-14T11:19:36.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>心有猛虎，细嗅蔷薇 </p></blockquote><a id="more"></a><h1 id="关于scrollTop-offsetTop-scrollLeft-offsetLeft用法介绍"><a href="#关于scrollTop-offsetTop-scrollLeft-offsetLeft用法介绍" class="headerlink" title="关于scrollTop,offsetTop,scrollLeft,offsetLeft用法介绍"></a>关于scrollTop,offsetTop,scrollLeft,offsetLeft用法介绍</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">页可见区域宽： <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">网页可见区域高： <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">网页可见区域宽： <span class="built_in">document</span>.body.offsetWidth (包括边线的宽);</span><br><span class="line">网页可见区域高： <span class="built_in">document</span>.body.offsetHeight (包括边线的宽);</span><br><span class="line">网页正文全文宽： <span class="built_in">document</span>.body.scrollWidth;</span><br><span class="line">网页正文全文高： <span class="built_in">document</span>.body.scrollHeight;</span><br><span class="line">网页被卷去的高： <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">网页被卷去的左： <span class="built_in">document</span>.body.scrollLeft;</span><br><span class="line">网页正文部分上： <span class="built_in">window</span>.screenTop;</span><br><span class="line">网页正文部分左： <span class="built_in">window</span>.screenLeft;</span><br><span class="line">屏幕分辨率的高： <span class="built_in">window</span>.screen.height;</span><br><span class="line">屏幕分辨率的宽： <span class="built_in">window</span>.screen.width;</span><br><span class="line">屏幕可用工作区高度： <span class="built_in">window</span>.screen.availHeight;</span><br></pre></td></tr></table></figure><p><img src="/img/location.jpeg"></p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="坐标事件"><a href="#坐标事件" class="headerlink" title="坐标事件"></a>坐标事件</h2><p>1.相对于显示屏左上角:e.screenX,e.screenY<br>2.相对于文档显示区左上角:e.clientX,e.clientY<br>3.相对于div左上角:e.offsetX,e.offsetY</p><hr><h2 id="页面滚动事件"><a href="#页面滚动事件" class="headerlink" title="页面滚动事件"></a>页面滚动事件</h2><p>window.onscroll  当页面滚动时触发<br>              获取滚动距离：document.body.scrollTop | |  document.documentElement.scrollTop<br>      主动控制页面的滚动位置：<br>            window.scrollTo（横向滚动到的位置，纵向滚动到的位置）<br>            window.scrollBy(横向滚动的距离，纵向滚动的距离)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;心有猛虎，细嗅蔷薇 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="screenX/screenY" scheme="https://zhanghuaxiao.github.io/tags/screenX-screenY/"/>
    
      <category term="clientX/slientY" scheme="https://zhanghuaxiao.github.io/tags/clientX-slientY/"/>
    
      <category term="offsetX/offsetY" scheme="https://zhanghuaxiao.github.io/tags/offsetX-offsetY/"/>
    
  </entry>
  
  <entry>
    <title>深度学习之神经网络</title>
    <link href="https://zhanghuaxiao.github.io/2019/02/04/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B9%8B%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://zhanghuaxiao.github.io/2019/02/04/深度学习之之神经网络/</id>
    <published>2019-02-04T09:50:33.000Z</published>
    <updated>2019-02-05T12:43:57.621Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>今天是19年除夕夜</p></blockquote><a id="more"></a><h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><p><a href="https://www.imooc.com/video/18099" target="_blank" rel="noopener">参考视频</a></p><h2 id="神经元————最小的神经网络"><a href="#神经元————最小的神经网络" class="headerlink" title="神经元————最小的神经网络"></a>神经元————最小的神经网络</h2><p><img src="/img/nerve.png"><br><img src="/img/nerve1.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>太枯燥看不下去了 😂</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;今天是19年除夕夜&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://zhanghuaxiao.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="神经网络" scheme="https://zhanghuaxiao.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>区块链理论和代码演示</title>
    <link href="https://zhanghuaxiao.github.io/2019/02/03/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF/"/>
    <id>https://zhanghuaxiao.github.io/2019/02/03/区块链技术/</id>
    <published>2019-02-03T13:28:21.000Z</published>
    <updated>2019-02-04T06:52:53.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>一场没有诗和远方，全是苟且的演讲</p></blockquote><p>无意间看晓说，他说5G对以后的影响，其中有个数据分发使用了比特币技术，对此查阅资料及视频进行学习，以下为个人总结<br><a id="more"></a><br>参考资料如何</p><ul><li><p><a href="https://v.youku.com/v_show/id_XMzk5Mzk3MjI4OA==.html?spm=a2h0j.11185381.listitem_page1.5!6~A&amp;&amp;s=6e782defbfbd0d4e11ef" target="_blank" rel="noopener">晓说视频</a></p></li><li><p><a href="https://www.imooc.com/video/17059" target="_blank" rel="noopener">讲解区块链原理视频</a></p></li><li><p><a href="https://www.imooc.com/video/17549" target="_blank" rel="noopener">区块链代码实现视频</a></p></li><li><p><a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">以太坊开源代码</a> 以太坊（英文Ethereum）是一个开源的有智能合约功能的公共区块链平台，通过其专用加密货币以太币（Ether）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。</p></li></ul><h2 id="区块链基本原型"><a href="#区块链基本原型" class="headerlink" title="区块链基本原型"></a>区块链基本原型</h2><ul><li>区块链本质就是 <strong>分布式数据库</strong></li><li>区块链是 <strong>公开的数据库</strong>，不是私人的数据库</li><li>区块链是加密货币和智能合约的基础</li></ul><h2 id="解决去中心问题"><a href="#解决去中心问题" class="headerlink" title="解决去中心问题"></a>解决去中心问题</h2><p>问：如何快速验证哪个数据才是正确的？<br>答：每次交易都记录 序号/时间戳/hash值，形成一个区块链，和其他区块进行对比</p><h2 id="如何确定使用权。"><a href="#如何确定使用权。" class="headerlink" title="如何确定使用权。"></a>如何确定使用权。</h2><p>问：账户所有权问题<br>    <img src="/img/ownership.png"><br>    <img src="/img/ownership1.png"><br>答：地址是用公钥通过hash值生成的，值再进行Base58进行编码的值,谁用这个地址支付，谁就拥有这个地址的所有权,谁有这个私钥，谁就能用这个地址支付，丢失私钥就是丢失使用权不能补办</p><h2 id="使用go语言模拟区块链技术基本原理"><a href="#使用go语言模拟区块链技术基本原理" class="headerlink" title="使用go语言模拟区块链技术基本原理"></a>使用go语言模拟区块链技术基本原理</h2><p><img src="/img/blockchain-basic-core.png"></p><h1 id="挖矿的本质"><a href="#挖矿的本质" class="headerlink" title="挖矿的本质"></a>挖矿的本质</h1><p>使用计算机计算，前面连续都是零的一串，记录交易信息的特殊的hash值生产的编码</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;一场没有诗和远方，全是苟且的演讲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无意间看晓说，他说5G对以后的影响，其中有个数据分发使用了比特币技术，对此查阅资料及视频进行学习，以下为个人总结&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://zhanghuaxiao.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链理论和代码演示" scheme="https://zhanghuaxiao.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE%E7%90%86%E8%AE%BA%E5%92%8C%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA/"/>
    
  </entry>
  
  <entry>
    <title>Vuejs源码解析</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/31/Vuejs%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/31/Vuejs源码解析/</id>
    <published>2019-01-31T08:40:13.000Z</published>
    <updated>2019-02-13T09:39:56.343Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>除了使用vue工具，更想揭开神秘面纱,开始一场神秘之旅吧 </p></blockquote><a id="more"></a><p><a href="https://github.com/vuejs/vue/blob/dev/src/core/instance/index.js" target="_blank" rel="noopener">vue.js源码地址</a></p><h1 id="看后感觉内容不错的参考资料"><a href="#看后感觉内容不错的参考资料" class="headerlink" title="看后感觉内容不错的参考资料"></a>看后感觉内容不错的参考资料</h1><p>1.<a href="http://hcysun.me/vue-design/art/2vue-constructor.html" target="_blank" rel="noopener">Vue技术内幕</a></p><h1 id="从一个简单的example开始"><a href="#从一个简单的example开始" class="headerlink" title="从一个简单的example开始"></a>从一个简单的example开始</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;&#123;&#123;test&#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">var vm = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">el: '#app',</span></span><br><span class="line"><span class="regexp">data: &#123;</span></span><br><span class="line"><span class="regexp">        test: 1</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>这段代码简单调用了<em>Vue</em>，传递了两个选项 <em>el</em> 和 <em>data</em>,这段代码在页面呈现的DOM如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;<span class="number">1</span>&lt;div&gt;</span><br></pre></td></tr></table></figure></p><h2 id="接下来我们看看上面的例子到底发生了什么？"><a href="#接下来我们看看上面的例子到底发生了什么？" class="headerlink" title="接下来我们看看上面的例子到底发生了什么？"></a>接下来我们看看上面的例子到底发生了什么？</h2><p>首先当我们使用Vue构造函数的时候，第一句执行的代码到底是什么，所以我们找到Vue的构造函数，Vue的构造函数在<em>core/instance/index.js</em><br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">        !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">    ) &#123;</span><br><span class="line">        warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码一目了然，当new Vue构造函数时，执行的第一句代码时this._init(options)方法，options参数内容是我们调用Vue构造函数传入的<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">options = &#123;</span><br><span class="line">    el:<span class="string">'#app'</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">        test:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>既然如此我们就找到 <em>_init方法</em>，_init 方法在 src/core/instance/init.js 文件被添加到 Vue 的原型上，下面我们就看看 _init 做了什么。<br>_init 方法的一开始，是这两句代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm: Component = <span class="keyword">this</span></span><br><span class="line"><span class="comment">// a uid</span></span><br><span class="line">vm._uid = uid++</span><br></pre></td></tr></table></figure></p><p>首先声明了一个常量vm，并且在vm上添加了一个属性 <em>_uid</em>，uid的初始值是0每次实例化一个 Vue 实例之后，uid 的值都会 ++。</p><h2 id="接下去的代码如下"><a href="#接下去的代码如下" class="headerlink" title="接下去的代码如下"></a>接下去的代码如下</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> startTag, endTag</span><br><span class="line"><span class="comment">/* istanbul ignore if */</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">  endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">  mark(startTag)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先声明了startTag, endTag这两个参数(parameter)，其中if括号中的意思是：在非生产环境下，并且config.performance和mark都为真，才执行里面的代码，其中 config.performance 来自于 core/config.js 文件，我们知道，Vue.config 同样引用了这个对象，在 Vue 的官方文档中可以看到如下内容：<br><strong>Vue 提供了全局配置 Vue.config.performance，我们通过将其设置为 true，即可开启性能追踪</strong></p><h2 id="你可以追踪四个场景的性能"><a href="#你可以追踪四个场景的性能" class="headerlink" title="你可以追踪四个场景的性能"></a>你可以追踪四个场景的性能</h2><p>1、组件初始化(component init)<br>2、编译(compile)，将模板(template)编译成渲染函数<br>3、渲染(render)，其实就是渲染函数的性能，或者说渲染函数执行且生成虚拟DOM(vnode)的性能<br>4、打补丁(patch)，将虚拟DOM渲染为真实DOM的性能</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;除了使用vue工具，更想揭开神秘面纱,开始一场神秘之旅吧 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue中diff算法详解</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/30/vue-diff%E7%AE%97%E6%B3%95/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/30/vue-diff算法/</id>
    <published>2019-01-30T04:53:01.000Z</published>
    <updated>2019-02-14T07:15:32.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p><a href="https://zhanghuaxiao.github.io/2019/01/30/vue-source-code/">可以先看Vuejs运行机制</a></p></blockquote><a id="more"></a><h1 id="当数据发生变化时，vue是怎么更新节点的？"><a href="#当数据发生变化时，vue是怎么更新节点的？" class="headerlink" title="当数据发生变化时，vue是怎么更新节点的？"></a>当数据发生变化时，vue是怎么更新节点的？</h1><p>要知道渲染真实DOM的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，有没有可能我们只更新我们修改的那一小块dom而不要更新整个dom呢？diff算法能够帮助我们。</p><p>我们先根据真实DOM生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的DOM上，然后使oldVnode的值为Vnode。</p><p>diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁。</p><h1 id="virtual-DOM和真实DOM的区别？"><a href="#virtual-DOM和真实DOM的区别？" class="headerlink" title="virtual DOM和真实DOM的区别？"></a>virtual DOM和真实DOM的区别？</h1><p>virtual DOM是将真实的DOM的数据抽取出来，以对象的形式模拟树形结构。比如dom是这样的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p&gt;<span class="number">123</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">对应的virtual DOM（伪代码）：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> Vnode = &#123;</span><br><span class="line">        tag: <span class="string">'div'</span>,</span><br><span class="line">        children: [</span><br><span class="line">            &#123; <span class="attr">tag</span>: <span class="string">'p'</span>, <span class="attr">text</span>: <span class="string">'123'</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>（温馨提示：VNode和oldVNode都是对象，一定要记住）</p><h1 id="diff的比较方式？"><a href="#diff的比较方式？" class="headerlink" title="diff的比较方式？"></a>diff的比较方式？</h1><p>在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;<span class="number">123</span>&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;span&gt;<span class="number">456</span>&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure></p><p>上面的代码会分别比较同一层的两个div以及第二层的p和span，但是不会拿div和span作比较。在别处看到的一张很形象的图：<br><img src="/img/diff.png"></p><h1 id="diff流程图"><a href="#diff流程图" class="headerlink" title="diff流程图"></a>diff流程图</h1><p>当数据发生改变时，set方法会让调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图<br><img src="/img/diff-diagram.png"></p><h1 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h1><p>patch<br>来看看patch是怎么打补丁的（代码只保留核心部分）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode,vnode</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//some code</span></span><br><span class="line">    <span class="keyword">if</span>(sameVnode(oldVnode,vnode))&#123;</span><br><span class="line">        patchVnode(oldVnode,vnode)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> oEl = oldVnode.el   <span class="comment">//当前oldVnode对应的真实元素节点</span></span><br><span class="line">        <span class="keyword">let</span> parentEle = api.parentNode(oEl)   <span class="comment">//父元素</span></span><br><span class="line">        createEle(vnode)   <span class="comment">//根据Vnode生成新元素</span></span><br><span class="line">            <span class="keyword">if</span> (parentEle !== <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将新元素添加进父元素    </span></span><br><span class="line">            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) </span><br><span class="line">            api.removeChild(parentEle, oldVnode.el)  <span class="comment">// 移除以前的旧元素节点</span></span><br><span class="line">            oldVnode = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// some code </span></span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>patch函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点</p><p><em>判断两节点是否值得比较，值得比较则执行patchVnode</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        a.key === b.key &amp;&amp;  <span class="comment">// key值</span></span><br><span class="line">        a.tag === b.tag &amp;&amp;  <span class="comment">// 标签名</span></span><br><span class="line">        a.isComment === b.isComment &amp;&amp;  <span class="comment">// 是否为注释节点</span></span><br><span class="line">        <span class="comment">// 是否都定义了data，data包含一些具体信息，例如onclick , style</span></span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;  </span><br><span class="line">        sameInputType(a, b) <span class="comment">// 当标签是&lt;input&gt;的时候，type必须相同</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>不值得比较则用Vnode替换oldVnode</em><br>如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。</p><p>虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…其实没这么简单，它利用闭包有个缓存机制）</p><h1 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h1><p>当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    patchVnode (oldVnode, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> el = vnode.el = oldVnode.el</span><br><span class="line">    <span class="keyword">let</span> i, oldCh = oldVnode.children, ch = vnode.children</span><br><span class="line">    <span class="keyword">if</span> (oldVnode === vnode) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.text !== <span class="literal">null</span> &amp;&amp; vnode.text !== <span class="literal">null</span> &amp;&amp; oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        api.setTextContent(el, vnode.text)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        updateEle(el, vnode, oldVnode)</span><br><span class="line">        <span class="keyword">if</span> (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123;</span><br><span class="line">            updateChildren(el, oldCh, ch)</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ch)&#123;</span><br><span class="line">            createEle(vnode) <span class="comment">//create el's children dom</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldCh)&#123;</span><br><span class="line">            api.removeChildren(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数做了以下事情：</p><p>找到对应的真实dom，称为el<br>判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return<br>如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。<br>如果oldVnode有子节点而Vnode没有，则删除el的子节点<br>如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el<br>如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要<br>其他几个点都很好理解，我们详细来讲一下updateChildren</p><h1 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">    updateChildren (parentElm, oldCh, newCh) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStartIdx = <span class="number">0</span>, newStartIdx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldEndIdx = oldCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> oldStartVnode = oldCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    <span class="keyword">let</span> newEndIdx = newCh.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> newStartVnode = newCh[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> newEndVnode = newCh[newEndIdx]</span><br><span class="line">    <span class="keyword">let</span> oldKeyToIdx</span><br><span class="line">    <span class="keyword">let</span> idxInOld</span><br><span class="line">    <span class="keyword">let</span> elmToMove</span><br><span class="line">    <span class="keyword">let</span> before</span><br><span class="line">    <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldStartVnode == <span class="literal">null</span>) &#123;   <span class="comment">// 对于vnode.key的比较，会把oldVnode = null</span></span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx] </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (oldEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newEndVnode == <span class="literal">null</span>) &#123;</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode)</span><br><span class="line">            api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用key时的比较</span></span><br><span class="line">            <span class="keyword">if</span> (oldKeyToIdx === <span class="literal">undefined</span>) &#123;</span><br><span class="line">                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) <span class="comment">// 有key生成index表</span></span><br><span class="line">            &#125;</span><br><span class="line">            idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">            <span class="keyword">if</span> (!idxInOld) &#123;</span><br><span class="line">                api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                elmToMove = oldCh[idxInOld]</span><br><span class="line">                <span class="keyword">if</span> (elmToMove.sel !== newStartVnode.sel) &#123;</span><br><span class="line">                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    patchVnode(elmToMove, newStartVnode)</span><br><span class="line">                    oldCh[idxInOld] = <span class="literal">null</span></span><br><span class="line">                    api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)</span><br><span class="line">                &#125;</span><br><span class="line">                newStartVnode = newCh[++newStartIdx]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        before = newCh[newEndIdx + <span class="number">1</span>] == <span class="literal">null</span> ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].el</span><br><span class="line">        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先说一下这个函数做了什么</p><ul><li>将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来</li><li>oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。</li></ul><h1 id="图解updateChildren"><a href="#图解updateChildren" class="headerlink" title="图解updateChildren"></a>图解updateChildren</h1><p>终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。<br><img src="/img/updateChildren.png"><br>现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，这句话有点绕，打个比方</p><ul><li>如果是oldS和E匹配上了，那么真实dom中的第一个节点会移到最后</li><li>如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到最前，匹配上的两个指针向中间移动</li><li>如果四种匹配没有一对是成功的，那么遍历oldChild，S挨个和他们匹配，匹配成功就在真实dom中将成功的节点移到最前面，如果依旧没有成功的，那么将S对应的节点插入到dom中对应的oldS位置，oldS和S指针向中间移动。<br><img src="/img/sameVnode.png"></li></ul><p>第一步</p><pre><code>oldS = a, oldE = d；S = a, E = b;</code></pre><p>oldS和S匹配，则将dom中的a节点放到第一个，已经是第一个了就不管了，此时dom的位置为：a b d<br>第二步</p><pre><code>oldS = b, oldE = d；S = c, E = b;</code></pre><p>oldS和E匹配，就将原本的b节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实dom中的相应节点会移到Vnode相应的位置，此时dom的位置为：a d b<br>第三步</p><pre><code>oldS = d, oldE = d；S = c, E = d;</code></pre><p>oldE和E匹配，位置不变此时dom的位置为：a d b<br>第四步</p><pre><code>oldS++;oldE--;oldS &gt; oldE;</code></pre><p>遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的index插入到真实dom中去，此时dom位置为：a c d b<br>一次模拟完成。<br>这个匹配过程的结束有两个条件：</p><ul><li>oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据index添加到dom中去（如上图）</li><li>S &gt; E表示vCh先遍历完，那么就在真实dom中将区间为[oldS, oldE]的多余节点删掉</li></ul><p><img src="/img/dom.png"></p><p>下面再举一个例子，可以像上面那样自己试着模拟一下<br><img src="/img/dom1.png"></p><p>当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">    patchVnode(oldStartVnode, newStartVnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。也将dom的所有补丁都打好啦。那么现在再回过去看updateChildren的代码会不会容易很多呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://zhanghuaxiao.github.io/2019/01/30/vue-source-code/&quot;&gt;可以先看Vuejs运行机制&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="vue的diff算法" scheme="https://zhanghuaxiao.github.io/tags/vue%E7%9A%84diff%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 内部运行机制</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/30/vue-source-code/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/30/vue-source-code/</id>
    <published>2019-01-30T03:37:58.000Z</published>
    <updated>2019-01-30T06:35:13.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>生活的全部意义在于无穷地探索尚未知道的东西，在于不断地增加更多的知识。————左拉 </p></blockquote><p><img src="/img/curious.jpg"><br><a id="more"></a><br><a href="https://juejin.im/book/5a36661851882538e2259c0f/section/5a37bbb35188257d167a4d64" target="_blank" rel="noopener">原文地址</a></p><h1 id="全局概览"><a href="#全局概览" class="headerlink" title="全局概览"></a>全局概览</h1><p>这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。</p><p>首先我们来看一下笔者画的内部流程图。<br><img src="/img/vuejsfrist.png" class="full-image"><br>大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。</p><h1 id="初始化及挂载"><a href="#初始化及挂载" class="headerlink" title="初始化及挂载"></a>初始化及挂载</h1><p><img src="/img/vuejs2.png" class="full-image"><br>在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」，后面会详细讲到，这里只要有一个印象即可。</p><p>初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。<br><img src="/img/vuejs3.png" class="full-image"></p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>parse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。</p><h2 id="optimize"><a href="#optimize" class="headerlink" title="optimize"></a>optimize</h2><p>optimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， <a href="https://zhanghuaxiao.github.io/2019/01/30/vue-diff算法/#more">diff</a> 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><p>generate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。</p><p>在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。</p><h1 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h1><p>接下来也就是 Vue.js 响应式核心部分。<br><img src="/img/vuejs4.png" class="full-image"></p><p>这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。</p><p>当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。<br><img src="/img/vuejs5.png" class="full-image"></p><p>在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。</p><h1 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h1><p>我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。</p><p>比如说下面这样一个例子：</p><pre><code>{    tag: &apos;div&apos;,                 /*说明这是一个div标签*/    children: [                 /*存放该标签的子节点*/        {            tag: &apos;a&apos;,           /*说明这是一个a标签*/            text: &apos;click me&apos;    /*标签的内容*/        }    ]}</code></pre><p>渲染后可以得到</p><pre><code>&lt;div&gt;    &lt;a&gt;click me&lt;/a&gt;&lt;/div&gt;</code></pre><p>这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。</p><h1 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h1><p><img src="/img/vuejs6.png" class="full-image"><br>前面我们说到，在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？</p><p>当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。</p><p>那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。</p><h1 id="再看全局"><a href="#再看全局" class="headerlink" title="再看全局"></a>再看全局</h1><p><img src="/img/vuejs7.png" class="full-image"><br>回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;生活的全部意义在于无穷地探索尚未知道的东西，在于不断地增加更多的知识。————左拉 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/curious.jpg&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="Vue.js 内部运行机制" scheme="https://zhanghuaxiao.github.io/tags/Vue-js-%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    
      <category term="patch" scheme="https://zhanghuaxiao.github.io/tags/patch/"/>
    
      <category term="render function" scheme="https://zhanghuaxiao.github.io/tags/render-function/"/>
    
      <category term="diff" scheme="https://zhanghuaxiao.github.io/tags/diff/"/>
    
  </entry>
  
  <entry>
    <title>gulp和webpack区别</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/29/gulp%E5%92%8Cwebpack%E5%8C%BA%E5%88%AB/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/29/gulp和webpack区别/</id>
    <published>2019-01-29T01:48:44.000Z</published>
    <updated>2019-01-29T04:52:05.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>我愿化身石桥，受五百年风吹，五百年日晒，五百年雨淋，只求她从桥上经过</p></blockquote><a id="more"></a><blockquote><p><a href="https://www.cnblogs.com/lovesong/p/6413546.html" target="_blank" rel="noopener">原文地址</a></p></blockquote><h1 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a>gulp</h1><p>gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。</p><p>PS：简单说就一个Task Runner</p><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。<br>PS：webpack is a module bundle</p><h1 id="相同功能"><a href="#相同功能" class="headerlink" title="相同功能"></a>相同功能</h1><p>gulp与webpack可以实现一些相同功能，如下（列举部分）：</p><table><thead><tr><th>功能</th><th style="text-align:center">gulp</th><th style="text-align:right">webpack</th></tr></thead><tbody><tr><td>文件合并与压缩（css）</td><td style="text-align:center">使用gulp-minify-css模块</td><td style="text-align:right">样式合并一般用到extract-text-webpack-plugin插件压缩则使用webpack.optimize.UglifyJsPlugin</td></tr><tr><td>文件合并与压缩（js）</td><td style="text-align:center">使用gulp-uglify和gulp-concat两个模块</td><td style="text-align:right">js合并在模块化开始就已经做,压缩则使用webpack.optimize.UglifyJsPlugin </td></tr><tr><td>sass/less预编译</td><td style="text-align:center">使用gulp-sass/gulp-less 模块</td><td style="text-align:right">sass-loader/less-loader 进行预处理 </td></tr><tr><td>启动server</td><td style="text-align:center">使用gulp-webserver模块</td><td style="text-align:right">使用webpack-dev-server模块</td></tr><tr><td>版本控制</td><td style="text-align:center">使用gulp-rev和gulp-rev-collector两个模块</td><td style="text-align:right">将生成文件加上hash值 module.exports = {plugins:[new ExtractTextPlugin(style.[hash].css”)}</td></tr></tbody></table><h1 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h1><ul><li>虽然都是前端自动化构建工具，但看他们的定位就知道不是对等的。</li><li>gulp严格上讲，模块化不是他强调的东西，他旨在规范前端开发流程。</li><li>webpack更是明显强调模块化开发，而那些文件压缩合并、预处理等功能，不过是他附带的功能。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>gulp应该与grunt比较，而webpack应该与browserify（网上太多资料就这么说，这么说是没有错，不过单单这样一句话并不能让人清晰明了）。</li><li>gulp与webpack上是互补的，还是可替换的，取决于你项目的需求。如果只是个vue或react的单页应用，webpack也就够用；如果webpack某些功能使用起来麻烦甚至没有（雪碧图就没有），那就可以结合gulp一起用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;我愿化身石桥，受五百年风吹，五百年日晒，五百年雨淋，只求她从桥上经过&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="gulp和webpack区别" scheme="https://zhanghuaxiao.github.io/tags/gulp%E5%92%8Cwebpack%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>js模块化编程弄懂CommonJS和AMD/CMD！</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/28/CommonJs-AMD-CMD/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/28/CommonJs-AMD-CMD/</id>
    <published>2019-01-28T03:40:04.000Z</published>
    <updated>2019-01-28T09:14:51.603Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>为什么模块很重要？ </p></blockquote><p>因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。<br>但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！<br><a id="more"></a></p><blockquote><p><a href="https://www.cnblogs.com/chenguangliang/p/5856701.html" target="_blank" rel="noopener">原文链接</a></p></blockquote><h1 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h1><p>   一开始大家都认为JS是辣鸡，没什么用，官方定义的API只能构建基于浏览器的应用程序，逗我呢，这太狭隘了吧(用了个高端词，嘎嘎)，CommonJS就按耐不住了，CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。这样的话，开发者可以使用CommonJS API编写应用程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。<br>在兼容CommonJS的系统中，你可以使用JavaScript开发以下程序：</p><p>(1).服务器端JavaScript应用程序<br>(2).命令行工具<br>(3).图形界面应用程序<br>(4).混合应用程序（如，Titanium或Adobe AIR）</p><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。</p><p>node.js的<a href="https://nodejs.org/docs/latest/api/modules.html" target="_blank" rel="noopener">模块系统</a>，就是参照<a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noopener">CommonJS</a>规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。假定有一个数学模块math.js，就可以像下面这样加载。</p><p>var math = require(‘math’);</p><p>然后，就可以调用模块提供的方法：</p><p>　　var math = require(‘math’);</p><pre><code>math.add(2,3); // 5</code></pre><p>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}</p><p>require()用来引入外部模块；exports对象用于导出当前模块的方法或变量，唯一的导出口；module对象就代表模块本身。</p><p>虽说Node遵循CommonJS的规范，但是相比也是做了一些取舍，填了一些新东西的。</p><p>不过，说了CommonJS也说了Node，那么我觉得也得先了解下NPM了。NPM作为Node的包管理器，不是为了帮助Node解决依赖包的安装问题嘛，那它肯定也要遵循CommonJS规范啦，它遵循包规范（还是理论）的。CommonJS WIKI讲了它的历史，还介绍了modules和packages等。</p><p>下面讲讲commonJS的原理以及简易实现：</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a><font color="#0099ff" size="3" face="黑体">原理</font></h2><p>浏览器不支持CommonJS原因，在于缺少四个Node.js环境变量</p><blockquote><ul><li>module</li><li>exports</li><li>require</li><li>global<br>只要能提供这4个变量，浏览器就能加载CommonJS模块<br>下面一个简单示例</li></ul></blockquote><pre><code>var module = {    exports : {}};(function(module,exports){    exports.multiply = function(n){return n*100}}(module,module.exports))var f = module.exports.multiply;f(5) // 500</code></pre><p>上面代码向一个立即执行函数提供 module 和 exports 两个外部变量，模块就放在这个立即执行函数里面。模块的输出值放在 module.exports 之中，这样就实现了模块的加载。</p><h2 id="Browserify-的实现"><a href="#Browserify-的实现" class="headerlink" title="Browserify 的实现"></a><font color="#0099ff" size="3" face="黑体">Browserify 的实现</font></h2><p>知道了原理，就能做出工具了。<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a> 是目前最常用的 CommonJS 格式转换的工具。</p><p>请看一个例子，main.js 模块加载 foo.js 模块。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// foo.js</span><br><span class="line">module.exports = function(x) &#123;</span><br><span class="line">console.log(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">var foo = require(&quot;./foo&quot;);</span><br><span class="line">foo(&quot;Hi&quot;);</span><br></pre></td></tr></table></figure></p><pre><code>使用下面的命令，就能将main.js转为浏览器可用的格式。</code></pre><p>$ browserify main.js &gt; compiled.js<br>Browserify到底做了什么？安装一下browser-unpack，就能看清楚了。<br>$ npm install browser-unpack -g<br>然后，将前面生成的compile.js解包。<br>    $ browser-unpack &lt; compiled.js<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;:1,</span><br><span class="line">        &quot;source&quot;:&quot;module.exports = function(x) &#123;\n  console.log(x);\n&#125;;&quot;,</span><br><span class="line">        &quot;deps&quot;:&#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;id&quot;:2,</span><br><span class="line">        &quot;source&quot;:&quot;var foo = require(\&quot;./foo\&quot;);\nfoo(\&quot;Hi\&quot;);&quot;,</span><br><span class="line">        &quot;deps&quot;:&#123;&quot;./foo&quot;:1&#125;,</span><br><span class="line">        &quot;entry&quot;:true</span><br><span class="line">    &#125;</span><br><span class="line">] </span><br></pre></td></tr></table></figure><br>可以看到，browerify 将所有模块放入一个数组，id 属性是模块的编号，source 属性是模块的源码，deps 属性是模块的依赖。</p><p>因为main.js加载了foo.js,所以deps属性就指定./foo对应1号模块。执行时候，浏览器遇到require(./foo)语句，就自动执行1好模块的source属性，并将执行后module.exports属性值输出   </p><h2 id="Tiny-Browser-Require"><a href="#Tiny-Browser-Require" class="headerlink" title="Tiny Browser Require"></a><font color="#0099ff" size="3" face="黑体">Tiny Browser Require</font></h2><p>虽然 Browserify 很强大，但不能在浏览器里操作，有时就很不方便。<br>我根据 <a href="https://github.com/mochajs/mocha" target="_blank" rel="noopener">mocha</a> 的内部实现，做了一个纯浏览器的 CommonJS 模块加载器 <a href="https://github.com/ruanyf/tiny-browser-require" target="_blank" rel="noopener">tiny-browser-require</a> 。完全不需要命令行，直接放进浏览器即可，所有代码只有30多行。</p><p>它的逻辑非常简单，就是把模块读入数组，加载路径就是模块的id。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  function require(p)&#123;</span><br><span class="line">  var path = require.resolve(p); //node.js语法加载当前模块目录下的绝对路径</span><br><span class="line">  var mod = require.modules[path];</span><br><span class="line">  if (!mod) throw new Error(&apos;failed to require &quot;&apos; + p + &apos;&quot;&apos;);</span><br><span class="line">  if (!mod.exports) &#123;</span><br><span class="line">    mod.exports = &#123;&#125;;</span><br><span class="line">    mod.call(mod.exports, mod, mod.exports, require.relative(path));</span><br><span class="line">  &#125;</span><br><span class="line">  return mod.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">require.modules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">require.resolve = function (path)&#123;</span><br><span class="line">  var orig = path;</span><br><span class="line">  var reg = path + &apos;.js&apos;;</span><br><span class="line">  var index = path + &apos;/index.js&apos;;</span><br><span class="line">  return require.modules[reg] &amp;&amp; reg</span><br><span class="line">    || require.modules[index] &amp;&amp; index</span><br><span class="line">    || orig;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">require.register = function (path, fn)&#123;</span><br><span class="line">  require.modules[path] = fn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">require.relative = function (parent) &#123;</span><br><span class="line">  return function(p)&#123;</span><br><span class="line">    if (&apos;.&apos; != p.charAt(0)) return require(p);</span><br><span class="line">    var path = parent.split(&apos;/&apos;);</span><br><span class="line">    var segs = p.split(&apos;/&apos;);</span><br><span class="line">    path.pop();</span><br><span class="line"></span><br><span class="line">    for (var i = 0; i &lt; segs.length; i++) &#123;</span><br><span class="line">      var seg = segs[i];</span><br><span class="line">      if (&apos;..&apos; == seg) path.pop();</span><br><span class="line">      else if (&apos;.&apos; != seg) path.push(seg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return require(path.join(&apos;/&apos;));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>使用的时候，先将上面的代码放入页面。然后，将模块放在如下的立即执行函数里面，就可以调用了。</p><pre><code>&lt;script src=&quot;require.js&quot; /&gt;&lt;script&gt;    require.register(&quot;moduleId&quot;, function(module, exports, require){    // Module code goes here    });    var result = require(&quot;moduleId&quot;);&lt;/script&gt;</code></pre><p>还是以前面的 main.js 加载 foo.js 为例。</p><pre><code>require.register(&quot;./foo.js&quot;, function(module, exports, require){module.exports = function(x) {    console.log(x);    };});var foo = require(&quot;./foo.js&quot;);foo(&quot;Hi&quot;);</code></pre><p>注意，这个库只模拟了 require 、module 、exports 三个变量，如果模块还用到了 global 或者其他 Node 专有变量（比如 process），就通过立即执行函数提供即可。</p><h1 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h1><p>基于commonJS规范的nodeJS出来以后，服务端的模块概念已经形成，很自然地，大家就想要客户端模块。而且最好两者能够兼容，一个模块不用修改，在服务器和浏览器都可以运行。但是，由于一个重大的局限，使得CommonJS规范不适用于浏览器环境。还是上面的代码，如果在浏览器中运行，会有一个很大的问题，你能看出来吗？</p><blockquote><p>var math = require(‘math’);<br>math.add(2, 3);</p></blockquote><p>第二行math.add(2, 3)，在第一行require(‘math’)之后运行，因此必须等math.js加载完成。也就是说，如果加载时间很长，整个应用就会停在那里等。<font color="red">您会注意到 require 是同步的。</font></p><p>这对服务器端不是一个问题，因为所有的模块都存放在本地硬盘，可以同步加载完成，等待时间就是硬盘的读取时间。但是，对于浏览器，这却是一个大问题，因为模块都放在服务器端，等待时间取决于网速的快慢，可能要等很长时间，浏览器处于”假死”状态。</p><p>因此，浏览器端的模块，不能采用”同步加载”（synchronous），只能采用”异步加载”（asynchronous）。这就是AMD规范诞生的背景。</p><p>CommonJS是主要为了JS在后端的表现制定的，他是不适合前端的，AMD(异步模块定义)出现了，它就主要为前端JS的表现制定规范。</p><p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a>是”Asynchronous Module Definition”的缩写，意思就是”异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。</p><p>AMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：</p><pre><code>require([module], callback);</code></pre><p>第一个参数[module]，是一个数组，里面的成员就是要加载的模块；第二个参数callback，则是加载成功之后的回调函数。如果将前面的代码改写成AMD形式，就是下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">require([&apos;math&apos;], function (math) &#123;</span><br><span class="line">    math.add(2, 3);</span><br><span class="line">　&#125;);</span><br></pre></td></tr></table></figure></p><p>math.add()与math模块加载不是同步的，浏览器不会发生假死。所以很显然，AMD比较适合浏览器环境。目前，主要有两个Javascript库实现了AMD规范：<a href="https://requirejs.org/" target="_blank" rel="noopener">require.js</a>和<a href="https://github.com/cujojs/curl" target="_blank" rel="noopener">curl.js</a>。</p><font color="red">RequireJS就是实现了AMD规范的呢。</font><br><font size="2">详细概括：下面以RequireJS为例说明AMD规范</font><h2 id="为什么要用require-js？"><a href="#为什么要用require-js？" class="headerlink" title="为什么要用require.js？"></a><font color="#0099ff" size="3" face="黑体">为什么要用require.js？</font></h2><p>最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;2.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;3.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;5.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;6.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><br>这段代码依次加载多个js文件。<br>这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。</p><p>require.js的诞生，就是为了解决这两个问题：</p><blockquote><p>(1) 实现js文件的异步加载，避免网页失去响应；<br>(2) 管理模块之间的依赖性，便于代码的编写和维护。</p></blockquote><h2 id="require-js的加载"><a href="#require-js的加载" class="headerlink" title="require.js的加载"></a><font color="#0099ff" size="3" face="黑体">require.js的加载</font></h2><p>使用require.js的第一步，是先去官方网站<a href="https://requirejs.org/docs/download.html" target="_blank" rel="noopener">下载</a>最新版本。<br>下载后，假定把它放在js子目录下面，就可以加载了。</p><pre><code>&lt;script src=&quot;js/require.js&quot;&gt;&lt;/script&gt;</code></pre><p>有人可能会想到，加载这个文件，也可能造成网页失去响应。解决办法有两个，一个是把它放在网页底部加载，另一个是写成下面这样：</p><pre><code>&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt;</code></pre><p>async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。<br>加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：</p><pre><code>&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt;</code></pre><p>data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。</p><h2 id="主模块的写法"><a href="#主模块的写法" class="headerlink" title="主模块的写法"></a><font color="#0099ff" size="3" face="黑体">主模块的写法</font></h2><p>上一节的main.js，我把它称为”主模块”，意思是整个网页的入口代码。它有点像C语言的main()函数，所有代码都从这儿开始运行。<br>下面就来看，怎么写main.js。<br>如果我们的代码不依赖任何其他模块，那么可以直接写入javascript代码。</p><blockquote><p> // main.js<br>　　alert(“加载成功！”);</p></blockquote><p>但这样的话，就没必要使用require.js了。真正常见的情况是，主模块依赖于其他模块，这时就要使用AMD规范定义的的require()函数。</p><blockquote><p>   // main.js<br>　　require([‘moduleA’, ‘moduleB’, ‘moduleC’], function (moduleA, moduleB, moduleC){<br>　　　　// some code here<br>　　});</p></blockquote><p>require()函数接受两个参数。第一个参数是一个数组，表示所依赖的模块，上例就是[‘moduleA’, ‘moduleB’, ‘moduleC’]，即主模块依赖这三个模块；第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块。</p><p>require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p><p>下面，我们看一个实际的例子。<br>假定主模块依赖jquery、underscore和backbone这三个模块，main.js就可以这样写：</p><blockquote><p>require([‘jquery’, ‘underscore’, ‘backbone’], function ($, _, Backbone){<br>　　　　// some code here<br>　　});</p></blockquote><p>require.js会先加载jQuery、underscore和backbone，然后再运行回调函数。主模块的代码就写在回调函数中。</p><h2 id="模块的加载"><a href="#模块的加载" class="headerlink" title="模块的加载"></a><font color="#0099ff" size="3" face="黑体">模块的加载</font></h2><p>上一节最后的示例中，主模块的依赖模块是[‘jquery’, ‘underscore’, ‘backbone’]。默认情况下，require.js假定这三个模块与main.js在同一个目录，文件名分别为jquery.js，underscore.js和backbone.js，然后自动加载。</p><p>使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。</p><blockquote><p>   require.config({<br>　　　　paths: {<br>　　　　　　“jquery”: “jquery.min”,<br>　　　　　　“underscore”: “underscore.min”,<br>　　　　　　“backbone”: “backbone.min”<br>　　　　}<br>　　});</p></blockquote><p>上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。</p><blockquote><p>   require.config({<br>　　　　paths: {<br>　　　　　　“jquery”: “lib/jquery.min”,<br>　　　　　　“underscore”: “lib/underscore.min”,<br>　　　　　　“backbone”: “lib/backbone.min”<br>　　　　}<br>　　});</p></blockquote><p>另一种则是直接改变基目录（baseUrl）。</p><blockquote><p>   require.config({<br>　　　　baseUrl: “js/lib”,<br>　　　　paths: {<br>　　　　　　“jquery”: “jquery.min”,<br>　　　　　　“underscore”: “underscore.min”,<br>　　　　　　“backbone”: “backbone.min”<br>　　　　}<br>　　});</p></blockquote><p>如果某个模块在另一台主机上，也可以直接指定它的网址，比如：</p><blockquote><p>   require.config({<br>　　　　paths: {<br>　　　　　　“jquery”: “<a href="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;" target="_blank" rel="noopener">https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min&quot;</a><br>　　　　}<br>　　});</p></blockquote><p>require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个<a href="https://requirejs.org/docs/optimization.html" target="_blank" rel="noopener">优化工具</a>，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。</p><h2 id="AMD模块的写法"><a href="#AMD模块的写法" class="headerlink" title="AMD模块的写法"></a><font color="#0099ff" size="3" face="黑体">AMD模块的写法</font></h2><p>require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。</p><p>具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。</p><p>假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：</p><blockquote><p>   // math.js<br>　　define(function (){<br>　　　　var add = function (x,y){<br>　　　　　　return x+y;<br>　　　　};<br>　　　　return {<br>　　　　　　add: add<br>　　　　};<br>　　});</p></blockquote><p>加载方法如下：</p><blockquote><p>   // main.js<br>　　require([‘math’], function (math){<br>　　　　alert(math.add(1,1));<br>　　});</p></blockquote><p>如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。</p><blockquote><p>   define([‘myLib’], function(myLib){<br>　　　　function foo(){<br>　　　　　　myLib.doSomething();<br>　　　　}<br>　　　　return {<br>　　　　　　foo : foo<br>　　　　};<br>　　});</p></blockquote><p>当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。</p><h2 id="加载非规范的模块"><a href="#加载非规范的模块" class="headerlink" title="加载非规范的模块"></a><font color="#0099ff" size="3" face="黑体">加载非规范的模块</font></h2><p>理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？</p><p>回答是可以的。</p><p>这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。</p><p>举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。</p><blockquote><p>   require.config({<br>　　　　shim: {<br>　　　　　　‘underscore’:{<br>　　　　　　　　exports: ‘_’<br>　　　　　　},<br>　　　　　　‘backbone’: {<br>　　　　　　　　deps: [‘underscore’, ‘jquery’],<br>　　　　　　　　exports: ‘Backbone’<br>　　　　　　}<br>　　　　}<br>　　});</p></blockquote><p>require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。</p><p>比如，jQuery的插件可以这样定义：</p><blockquote><p>   shim: {<br>　　　　‘jquery.scroll’: {<br>　　　　　　deps: [‘jquery’],<br>　　　　　　exports: ‘jQuery.fn.scroll’<br>　　　　}<br>　　}</p></blockquote><h2 id="require-js插件"><a href="#require-js插件" class="headerlink" title="require.js插件"></a><font color="#0099ff" size="3" face="黑体">require.js插件</font></h2><p>require.js还提供一系列<a href="https://github.com/requirejs/requirejs/wiki/Plugins" target="_blank" rel="noopener">插件</a>，实现一些特定的功能。</p><p>domready插件，可以让回调函数在页面DOM结构加载完成后再运行。</p><blockquote><p>   require([‘domready!’], function (doc){<br>　　　　// called once the DOM is ready<br>　　});</p></blockquote><p>text和image插件，则是允许require.js加载文本和图片文件。</p><blockquote><p>　　   define([<br>　　　　‘text!review.txt’,<br>　　　　‘image!cat.jpg’<br>　　　　],<br>　　　　function(review,cat){<br>　　　　　　console.log(review);<br>　　　　　　document.body.appendChild(cat);<br>　　　　}<br>　　);</p></blockquote><p>类似的插件还有json和mdown，用于加载json文件和markdown文件。（完）</p><p>另一个人的概括(有点简单)：</p><p>AMD就只有一个接口：define(id?,dependencies?,factory);</p><p>它要在声明模块的时候制定所有的依赖(dep)，并且还要当做形参传到factory中，像这样：</p><blockquote><p>define([‘dep1’,’dep2’],function(dep1,dep2){…});</p></blockquote><p>要是没什么依赖，就定义简单的模块，下面这样就可以啦：</p><blockquote><pre><code>   define(function(){    var exports = {};    exports.method = function(){...};    return exports;});</code></pre></blockquote><p>咦，这里有define，把东西包装起来啦，那Node实现中怎么没看到有define关键字呢，它也要把东西包装起来呀，其实吧，只是Node隐式包装了而已…..</p><p>这有AMD的WIKI中文版，讲了很多蛮详细的东西，用到的时候可以查看：<a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="noopener">AMD的WIKI中文版</a></p><h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>大名远扬的玉伯写了seajs，就是遵循他提出的CMD规范，与AMD蛮相近的，不过用起来感觉更加方便些，最重要的是中文版，应有尽有：<a href="http://www6.seajs.org/?s_token=1548666648.0457692136&amp;kw=Javascript&amp;term=learn%20javascript&amp;term=javascript%20example&amp;term=module%20loader&amp;term=api%20integration&amp;term=javascript%20online%20courses&amp;showDomain=1&amp;backfill=0&amp;tdfs=1#docs" target="_blank" rel="noopener">seajs官方doc</a></p><blockquote><p>define(function(require,exports,module){…});</p></blockquote><p>用过seajs吧，这个不陌生吧，对吧。</p><p>前面说AMD，说RequireJS实现了AMD，CMD看起来与AMD好像呀，那RequireJS与SeaJS像不像呢？</p><p>虽然CMD与AMD蛮像的，但区别还是挺明显的，官方非官方都有阐述和理解，我觉得吧，说的都挺好：</p><p><a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">官方阐述SeaJS与RequireJS异同</a></p><p><a href="https://www.douban.com/note/283566440/" target="_blank" rel="noopener">SeaJS与RequireJS的最大异同（这个说的也挺好)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;为什么模块很重要？ &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。&lt;br&gt;但是，这样做有一个前提，那就是大家必须以同样的方式编写模块，否则你有你的写法，我有我的写法，岂不是乱了套！&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="CommonJS/AMD/CMD" scheme="https://zhanghuaxiao.github.io/tags/CommonJS-AMD-CMD/"/>
    
  </entry>
  
  <entry>
    <title>用 JavaScript 和 Emoji 做地址栏动画</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/27/Emojis-url/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/27/Emojis-url/</id>
    <published>2019-01-27T04:06:29.000Z</published>
    <updated>2019-01-27T04:28:32.875Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>同样是9年义务教育，你为何这么优秀 </p></blockquote><a id="more"></a><blockquote><p>译者：<a href="https://juejin.im/post/5c49b822f265da6142743a87" target="_blank" rel="noopener">Wpeach</a><br> 原文作者：Matthew Rayfield<br> 原文地址：<a href="http://matthewrayfield.com/articles/animating-urls-with-javascript-and-emojis/" target="_blank" rel="noopener">Animating URLs with Javascript and Emojis</a></p></blockquote><p> 你可以在地址栏使用 emoji（和其它图形 unicode 字符），这看着很棒，但是好像没人这么做，为什么呢？也许 emoji 对于正常的网络平台来说太过异国情调了？或许是他们因为害怕不利于SEO？<br>不管什么原因，维恩图中的合理性观点“没人这么做，但这是可能的”是让我兴奋的点。所以我决定花费一些时间研究在地址栏中图形字符的可能性，特别是通过 JavaScript 给这些字符加上动画。<br>循环动画<br>首先，确保你页面的 JavaScript 代码是 UTF-8 编码，否则无法在你的代码中显示 emoji，这可以通过设置 HTTP 头部或页面的 META 标签来实现。你很可能不用担心这个，但你可以在这里找到更多信息：Unicode in Javascript by Flavio。<br>为了达到我们想要的效果，让 emoji 像小仙女一样在地址栏里偏偏起舞，我们需要一个循环，实际上，我们所需要的只是一个循环，我们启动这个循环，它不断循环，我们的目的就达到了。这是我们的第一个循环动画，一个旋转的emoji 月亮。我猜当他们添加这个 emoji 序列时，也有这个想法吧？</p><pre><code>var f = [&apos;🌑&apos;, &apos;🌒&apos;, &apos;🌓&apos;, &apos;🌔&apos;, &apos;🌝&apos;, &apos;🌖&apos;, &apos;🌗&apos;, &apos;🌘&apos;];function loop() {    location.hash = f[Math.floor((Date.now()/100)%f.length)];    setTimeout(loop, 50);}loop();</code></pre><p>复制代码运行代码，你可以在地址栏看到此循环的结果。<br>如果你不喜欢旋转的月亮，你可以选择任何你喜欢的 emoji 来替换这个数组，比如一个时钟：</p><p>var f = [‘🕐’,’🕑’,’🕒’,’🕓’,’🕔’,’🕕’,’🕖’,’🕗’,’🕘’,’🕙’,’🕚’,’🕛’];<br>复制代码这是一个非常简单的例子，真的非常简单，所以我们来升级一下循环，让它显示一串 emoji ! 这次我们使用 emoji 的skin tone modifiers肤色调节属性来制作一些变色宝宝：</p><pre><code>var e = [&apos;🏻&apos;, &apos;🏼&apos;, &apos;🏽&apos;, &apos;🏾&apos;, &apos;🏿&apos;];function loop() {    var s = &apos;&apos;,        i, m;    for (i = 0; i &lt; 10; i ++) {        m = Math.floor(e.length * ((Math.sin((Date.now()/100) + i)+1)/2));        s += &apos;👶&apos; + e[m];    }    location.hash = s;    setTimeout(loop, 50);}loop(); </code></pre><p>复制代码我们可以使用时间和位置控制的正弦波来选择我们想要的颜色，这给了我们一个很好的颜色变幻效果！<br>比如我们再来一次月亮旋转，使它展开，制作一个类似于加载条的动画？好的，开始实现：</p><pre><code>var f = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;, &apos;🌔&apos;, &apos;🌓&apos;, &apos;🌒&apos;],    d = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],    m = 0;function loop() {    var s = &apos;&apos;, x = 0;    if (!m) {        while (d[x] == 4) {            x ++;        }        if (x &gt;= d.length) m = 1;        else {            d[x] ++;        }    }    else {        while (d[x] == 0) {            x ++;        }        if (x &gt;= d.length) m = 0;        else {            d[x] ++;            if (d[x] == 8) d[x] = 0;        }    }    d.forEach(function (n) {        s += f[n];    });    location.hash = s;    setTimeout(loop, 50);}loop();</code></pre><p>复制代码探索其它字符<br>不止是 emoji 给我们提供了一种在地址栏显示图形的方法，我们的目标中也有一些 unicode 字符。<br>特别有趣的是 框线字符:</p><p>它们中很多更适合二维输出，但它们在一维输出也很棒，例如，我们可以创建一个多个高度变化的块字符串，并构造一个漂亮的小波浪动画：</p><pre><code>function loop() {    var i, n, s = &apos;&apos;;    for (i = 0; i &lt; 10; i++) {        n = Math.floor(Math.sin((Date.now()/200) + (i/2)) * 4) + 4;        s += String.fromCharCode(0x2581 + n);    }    window.location.hash = s;    setTimeout(loop, 50);}loop();</code></pre><p>复制代码我非常喜欢它的效果，我把它永久放在了 wavyurl.com 上。<br>使用可变宽度字符，我们甚至在水平方向上摆动，创建类似于进度条的东西：</p><pre><code>function loop() {    var s = &apos;&apos;,        p;    p = Math.floor(((Math.sin(Date.now()/300)+1)/2) * 100);    while (p &gt;= 8) {        s += &apos;█&apos;;        p -= 8;    }    s += [&apos;⠀&apos;,&apos;▏&apos;,&apos;▎&apos;,&apos;▍&apos;,&apos;▌&apos;,&apos;▋&apos;,&apos;▊&apos;,&apos;▉&apos;][p];    location.hash = s;    setTimeout(loop, 50);}</code></pre><p>复制代码进度条？这看起来，还是有用的，这让我想到了……<br>在地址栏显示视频进度<br>为了增加我们小实验的可能性，我提出了在地址栏中显示网络视频进度的想法。我只需附加一个函数，将我们的进度字符串定义在视频的timeupdate事件中，瞧！地址栏中的视频进度条包含时间和持续时间！</p><pre><code>var video;function formatTime(seconds) {    var minutes = Math.floor(seconds/60),        seconds = Math.floor(seconds - (minutes*60));    return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2);}function renderProgressBar() {    var s = &apos;&apos;,        l = 15,        p = Math.floor(video.currentTime / video.duration * (l-1)),        i;    for (i = 0; i &lt; l; i ++) {        if (i == p) s +=&apos;◯&apos;;        else if (i &lt; p) s += &apos;─&apos;;        else s += &apos;┄&apos;;    }    location.hash = &apos;╭&apos;+s+&apos;╮&apos;+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration);}video = document.getElementById(&apos;video&apos;);video.addEventListener(&apos;timeupdate&apos;, renderProgressBar);</code></pre><p>复制代码我比较喜欢这个线条和圆组成的进度条，如果你喜欢别的 emoji 比如月亮，我也能让你满意：</p><pre><code>var e = [&apos;🌑&apos;, &apos;🌘&apos;, &apos;🌗&apos;, &apos;🌖&apos;, &apos;🌕&apos;],    video;function formatTime(seconds) {    var minutes = Math.floor(seconds/60),        seconds = Math.floor(seconds - (minutes*60));    return (&apos;0&apos;+minutes).substr(-2) + &apos;:&apos; + (&apos;0&apos;+seconds).substr(-2);}function renderProgressBar() {    var s = &apos;&apos;,        c = 0,        l = 10,        p = Math.floor(video.currentTime / video.duration * ((l*5)-1)),        i;    while (p &gt;= 5) {        s += e[4];        c ++;        p -= 5;    }    s += e[p];    c ++;    while (c &lt; l) {        s += e[0];        c ++;    }    location.hash = s+formatTime(video.currentTime)+&apos;╱&apos;+formatTime(video.duration);}video = document.getElementById(&apos;video&apos;);video.addEventListener(&apos;timeupdate&apos;, renderProgressBar);</code></pre><p>复制代码好的，将此进度条称为“有用”的延伸。 只瞄一眼，我也可以看到在视频分享 URL 中的进度。 与YouTube一样，你可以选择在特定时间创建指向视频的链接，添加视觉指示是不是很酷？嗯？<br>也许我还没有提出一些更有用的“技术”实现，我会继续思考这个问题。 嘿，也许你可以尝试一些东西？<br>最后<br>你可能想知道为什么我使用location.hash =，而不是新且酷的HTML5 History API。 有两个原因：<br>第一个问题是 History API有一个特点：它实际上更改了整个 URL 路径，而不仅仅是 hash。 因此，如果我使用 History API 并将页面更改为/🌑🌘🌗🌖🌕，它看起来会比添加 ＃ 更好。 但这也意味着我的 Web 服务器必须能够响应/🌑🌘🌗🌖🌕，否则如果用户刷新或以其他方式导航到修改后的 URL 将会失败。 这是可行的，但比使用location.hash =更复杂，需要我修改服务器配置。<br>第二个问题有些出乎意料。 实际上，在我测试的3个浏览器中，有2个历史API被限制的。 如果我以极快的速度将我的波形网址推送到地址栏，我最终会在 Chrome 中收到以下错误：</p><p>Throttling history state changes to prevent the browser from hanging.</p><p>Safari 给我们提供了更详细的信息：</p><p>SecurityError: Attempt to use history.pushState() more than 100 times per 30.000000 seconds</p><p>现在，如果让我保持在这个限制下也行，但是每秒3帧只是不会影响我目前的动画效果。<br>好孩子 Firefox 似乎并不在乎我推送新历史的次数和速度，这真是想得太周到了。但是，两个主要的浏览器受到影响，加上需要web服务器配置来修复第一个问题，使我更愿意忍受 URL 中的 #。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;同样是9年义务教育，你为何这么优秀 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="用JavaScript和Emoji 做地址栏动画" scheme="https://zhanghuaxiao.github.io/tags/%E7%94%A8JavaScript%E5%92%8CEmoji-%E5%81%9A%E5%9C%B0%E5%9D%80%E6%A0%8F%E5%8A%A8%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.29.0基本用法</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/25/webpack4-29-0/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/25/webpack4-29-0/</id>
    <published>2019-01-25T09:11:32.000Z</published>
    <updated>2019-01-30T06:36:48.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>不积跬步无以至千里，不积小流无以成江海 </p></blockquote><p>从2009到2019社会在不断进步 技术也在不断进步 我们当然也不能落后<br><img src="/img/jy.png"><br><a id="more"></a></p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li><p>全局安装webpack和webpack-cli</p><blockquote><p>sudo npm install webpack -g<br>sudo npm install webpack-cli -g</p></blockquote></li><li><p>文件夹下局部安装</p><blockquote><p>npm init -y<br>sudo npm install webpack –save-dev<br>sudo npm install webpack-cli –save-dev</p></blockquote></li></ul><h2 id="实现对一个js文件打包"><a href="#实现对一个js文件打包" class="headerlink" title="实现对一个js文件打包"></a>实现对一个js文件打包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode:&apos;development&apos;,</span><br><span class="line">    entry:&apos;./app.js&apos;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;[name].bundle.js&apos;,</span><br><span class="line">        path:path.join(__dirname,&apos;./dist&apos;),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">这样就能在dist目录下出现一个app.bundle.js文件啦！</span><br></pre></td></tr></table></figure><h2 id="实现多个js文件打包"><a href="#实现多个js文件打包" class="headerlink" title="实现多个js文件打包"></a>实现多个js文件打包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: &apos;./src/index.js&apos;,</span><br><span class="line">        test: &apos;./src/test.js&apos;,</span><br><span class="line">        test1: &apos;./src/test1.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname,&apos;./dist/js&apos;),</span><br><span class="line">        filename:&apos;[name]-[hash].js&apos;,</span><br><span class="line">        pubicPath: &apos;http://cdn.con&apos; //请求时会自己加协议（location.protocol=&apos;http&apos;）和端口号(host=&apos;cdn.con&apos;)</span><br><span class="line">    &#125;，</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin ([&apos;./dist/js&apos;]) //清除之前打包的文件</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用模版实现每个js对应自己的html"><a href="#使用模版实现每个js对应自己的html" class="headerlink" title="使用模版实现每个js对应自己的html"></a>使用模版实现每个js对应自己的html</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;) //模版loader</span><br><span class="line">const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        index:&apos;./src/index.js&apos;,</span><br><span class="line">        test:&apos;./src/test.js&apos;,</span><br><span class="line">        test1:&apos;./src/test1.js&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.join(__dirname,&apos;./dist/js&apos;),</span><br><span class="line">        filename:&apos;[name]-[hash].js&apos;,</span><br><span class="line">        publicPath:&quot;http://cdn.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: &apos;this a index.html&apos;, //每个html 的title</span><br><span class="line">            template:&apos;hello.html&apos;,</span><br><span class="line">            filename:&apos;index.html&apos;,</span><br><span class="line">            excludeChunks:[&apos;test&apos;,&apos;test1&apos;] //排除名为test.js,test1.js打包的js文件</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title:&apos;this a test.js&apos;,</span><br><span class="line">            template:&apos;hello.html&apos;,</span><br><span class="line">            filename:&apos;test.html&apos;,</span><br><span class="line">            excludeChunks:[&apos;index&apos;,&apos;test1&apos;]</span><br><span class="line">        &#125;),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title:&apos;this a test1.js&apos;,</span><br><span class="line">            template:&apos;hello.html&apos;,</span><br><span class="line">            filename:&apos;test1.html&apos;,</span><br><span class="line">            excludeChunks:[&apos;test&apos;,&apos;index&apos;]       </span><br><span class="line">        &#125;),</span><br><span class="line">        new CleanWebpackPlugin([&apos;./dist/js&apos;])</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//hello.html 模版内容</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title%&gt;&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    &lt;%=</span><br><span class="line">    compilation.assets[htmlWebpackPlugin.files.chunks.test1.entry.substr</span><br><span class="line">    (htmlWebpackPlugin.files.publicPath.length)].source() %&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;% for(let k in htmlWebpackPlugin.files.chunks) &#123;%&gt;</span><br><span class="line">        &lt;% if(k != &apos;index&apos;) &#123;%&gt;</span><br><span class="line">            &lt;script src=&quot;&lt;%=htmlWebpackPlugin.files.chunks[k].entry %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">        &lt;% &#125;%&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h2 id="使用file-loader-css-loader-style-loader-postcss-loader"><a href="#使用file-loader-css-loader-style-loader-postcss-loader" class="headerlink" title="使用file-loader|css-loader|style-loader|postcss-loader"></a>使用file-loader|css-loader|style-loader|postcss-loader</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//webpack.config.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">mode: &apos;development&apos;,</span><br><span class="line">entry: &apos;./app.js&apos;,</span><br><span class="line">output: &#123;</span><br><span class="line">    filename: &apos;[name].bundle.js&apos;,</span><br><span class="line">    path: path.join(__dirname, &apos;./dist/js1&apos;),</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    new CleanWebpackPlugin([&apos;./dist/js1&apos;]),</span><br><span class="line">    require(&apos;autoprefixer&apos;)</span><br><span class="line">],</span><br><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.(le|c)ss$/,</span><br><span class="line">        test: /\.(png|jpg|gif)$/,</span><br><span class="line">        use: [</span><br><span class="line">        &#123; loader: &quot;style-loader&quot; &#125;,</span><br><span class="line">        &#123; loader: &quot;css-loader&quot; &#125;,</span><br><span class="line">        &#123; loader: &apos;file-loader&apos;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: &quot;postcss-loader&quot;,</span><br><span class="line">            options: &#123;</span><br><span class="line">            plugins: [</span><br><span class="line">                require(&quot;autoprefixer&quot;) /*在这里添加*/,</span><br><span class="line">            ],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line"> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;不积跬步无以至千里，不积小流无以成江海 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从2009到2019社会在不断进步 技术也在不断进步 我们当然也不能落后&lt;br&gt;&lt;img src=&quot;/img/jy.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="webpack4+" scheme="https://zhanghuaxiao.github.io/tags/webpack4/"/>
    
  </entry>
  
  <entry>
    <title>使用github和hexo搭建个人博客</title>
    <link href="https://zhanghuaxiao.github.io/2019/01/24/posts/"/>
    <id>https://zhanghuaxiao.github.io/2019/01/24/posts/</id>
    <published>2019-01-24T06:16:00.000Z</published>
    <updated>2019-01-28T09:20:10.121Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>所谓博客，都是孤芳自赏 </p></blockquote><p>现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。<br><a id="more"></a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>下载node.js并安装（官网下载安装），默认会安装npm。</li><li>下载安装git（官网下载安装）</li><li>下载安装hexo。方法：打开cmd 运行npm install -g hexo</li></ul><h2 id="本地搭建hexo静态博客"><a href="#本地搭建hexo静态博客" class="headerlink" title="本地搭建hexo静态博客"></a>本地搭建hexo静态博客</h2><ul><li>新建一个文件夹，如MyBlog</li><li>进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，可能要翻墙）</li><li>生成完模板，运行npm install（目前貌似不用运行这一步）</li><li>最后运行：hexo server （运行程序，访问本地+localhost:4000可以看到博客已经搭建成功）</li></ul><h2 id="部署github"><a href="#部署github" class="headerlink" title="部署github"></a>部署github</h2><ul><li>在MyBlog下安装 <strong>npm install –save hexo-deployer-git</strong></li><li><p>找到_config.yml文件修改一下文件</p><blockquote><p>deploy:<br>type: git<br>repo: <a href="https://github.com/Zhanghuaxiao/Zhanghuaxiao.github.io.git" target="_blank" rel="noopener">https://github.com/Zhanghuaxiao/Zhanghuaxiao.github.io.git</a><br>branch: master</p></blockquote><p><img style="width:600px;height:200px" src="/img/urlimg.png" class="full-image"></p></li><li>最后运行 hexo clean(清除) hexo g(生成) hexo d(部署)</li><li>点击查看效果: <a href="https://zhanghuaxiao.github.io/">https://zhanghuaxiao.github.io/</a><br><img style="width:600px;height:200px" src="/img/github-pages.png" class="full-image"></li></ul><h2 id="使用nexT主题"><a href="#使用nexT主题" class="headerlink" title="使用nexT主题"></a>使用nexT主题</h2><ul><li>安装 git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next </li><li>修改_config.yml文件中 <strong>theme:next</strong></li><li>运行hexo clean  hexo s</li></ul><h2 id="hexo和nexT中文网"><a href="#hexo和nexT中文网" class="headerlink" title="hexo和nexT中文网"></a>hexo和nexT中文网</h2><blockquote><p>hexo中文网 <a href="https://hexo.io/zh-cn/docs/helpers" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/helpers</a><br>nexT中文官网 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">http://theme-next.iissnan.com/getting-started.html</a></p></blockquote><h2 id="nexT主题参考文章"><a href="#nexT主题参考文章" class="headerlink" title="nexT主题参考文章"></a>nexT主题参考文章</h2><blockquote><p>对nexT主题设置:<a href="https://segmentfault.com/a/1190000009544924#articleHeader2" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009544924#articleHeader2</a><br>seo优化:<a href="https://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">https://www.jianshu.com/p/86557c34b671</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;所谓博客，都是孤芳自赏 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在越来越多的人喜欢利用Github搭建静态网站，原因不外乎简单省钱。本人也利用hexo+github搭建了本博客，用于分享一些心得。在此过程中，折腾博客的各种配置以及功能占具了我一部分时间，在此详细记录下我是如何利用hexo+github搭建静态博客以及一些配置相关问题，以免过后遗忘，且当备份之用。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="https://zhanghuaxiao.github.io/categories/web/"/>
    
    
      <category term="hexo" scheme="https://zhanghuaxiao.github.io/tags/hexo/"/>
    
      <category term="nexT" scheme="https://zhanghuaxiao.github.io/tags/nexT/"/>
    
      <category term="搭建自己博客" scheme="https://zhanghuaxiao.github.io/tags/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
